     1                                      ; --- macro ---
     2                                      %include    "../include/define.s"
     1                              <1> ; defines of important constants
     2                              <1> 
     3                              <1> SECT_SIZE   equ     (512)                       ; size of a sector
     4                              <1> 
     5                              <1> 
     6                              <1> BOOT_LOAD   equ     0x7c00                      ; addr where boot program loaded
     7                              <1> BOOT_SIZE   equ     (1024 * 8)                  ; size of boot code
     8                              <1> BOOT_SECT   equ     (BOOT_SIZE / SECT_SIZE)     ; number of sectors used in boot program
     9                              <1> BOOT_END    equ     (BOOT_LOAD + BOOT_SIZE)     ; the end of boot code
    10                              <1> 
    11                              <1> E820_RECORD_SIZE    equ     20                  ; the record size (size of buffer for result) used in INT 0x15, EAX = 0xE820
    12                              <1> 
    13                              <1> 
    14                              <1> KERNEL_LOAD equ     0x0010_1000                 ; addr where the kernel loaded
    15                              <1> KERNEL_SIZE equ     (1024 * 8)                  ; size of the kernel
    16                              <1> KERNEL_SECT equ     (KERNEL_SIZE / SECT_SIZE)   ; number of sectors used in kernel
     3                                      %include    "../include/macro.s"
     1                              <1> ; --- cdecl ---
     2                              <1> 
     3                              <1> %macro cdecl 1-*.nolist
     4                              <1>     %rep    %0 - 1
     5                              <1>         push    %{-1:-1}
     6                              <1>         %rotate -1
     7                              <1>     %endrep
     8                              <1>     %rotate -1
     9                              <1> 
    10                              <1>     call    %1
    11                              <1> 
    12                              <1>     %if 1 < %0          ; delete args
    13                              <1>         add     sp, (__BITS__ >> 3) * (%0 - 1)      ; if realmode then __BITS__ = 16
    14                              <1>     %endif
    15                              <1> %endmacro
    16                              <1> 
    17                              <1> 
    18                              <1> ; --- drive struct ---
    19                              <1> struc drive
    20 00000000 <res 00000002>      <1>     .no     resw    1       ; drive number
    21 00000002 <res 00000002>      <1>     .cyln   resw    1       ; cylinder
    22 00000004 <res 00000002>      <1>     .head   resw    1       ; head
    23 00000006 <res 00000002>      <1>     .sect   resw    1       ; sector
    24                              <1> endstruc
     4                                  
     5                                      ORG     BOOT_LOAD
     6                                  
     7                                      ; --- entry point ---
     8                                  entry: 
     9 00000000 EB58                        jmp     ipl
    10                                  
    11                                  
    12                                      ; --- BIOS Parameter Block ---
    13 00000002 90<rept>                    times   90 - ($ - $$) db 0x90
    14                                  
    15                                  
    16                                      ; --- Initial Program Loader ---
    17                                  ipl:
    18                                  
    19 0000005A FA                          cli
    20                                  
    21 0000005B B80000                      mov     ax, 0x00
    22 0000005E 8ED8                        mov     ds, ax
    23 00000060 8EC0                        mov     es, ax
    24 00000062 8ED0                        mov     ss, ax                      ; ds = es = ss = 0
    25 00000064 BC007C                      mov     sp, BOOT_LOAD               ; sp = 0x7c00
    26                                  
    27 00000067 FB                          sti
    28                                  
    29 00000068 8816[B800]                  mov     [BOOT + drive.no],    dl    ; save drive number
    30                                  
    31 0000006C 68[9900]E84E0083C4-         cdecl   puts, .s0                   ; write text in teletype mode
    31 00000074 02                 
    32                                  
    33                                  
    34                                      ; read all the sectors left
    35 00000075 BB0F00                      mov     bx, BOOT_SECT - 1               ; bx = number of sectors left
    36 00000078 B9007E                      mov     cx, BOOT_LOAD + SECT_SIZE       ; cx = addr where next sectors will be loaded
    37 0000007B 515368[B800]E89B00-         cdecl   read_chs, BOOT, bx, cx          ; ax = read_chs(BOOT, bx, cx);
    37 00000083 83C406             
    38                                  
    39 00000086 39D8                        cmp     ax, bx
    40 00000088 740C                        jz      .10E                    ; if success, jump to .10E
    41                                  
    42 0000008A 68[A600]E8300083C4-         cdecl   puts, .e0
    42 00000092 02                 
    43 00000093 E84900                      call    reboot
    44                                  .10E:
    45                                      ; transition to the 2nd stage
    46 00000096 E96902                      jmp     stage_2
    47                                  
    48                                  
    49                                  
    50 00000099 426F6F74696E672E2E-     .s0:    db  "Booting...", 0x0A, 0x0D, 0x00
    50 000000A2 2E0A0D00           
    51 000000A6 4572726F723A736563-     .e0:    db  "Error:sector read", 0x00
    51 000000AF 746F72207265616400 
    52                                  
    53                                      ALIGN 2, db 0
    54                                  BOOT:
    55                                      istruc  drive
    56 000000B8 0000                            at  drive.no,   dw  0   ; drive number
    57 000000BA 0000                            at  drive.cyln, dw  0   ; cylinder
    58 000000BC 0000                            at  drive.head, dw  0   ; head
    59 000000BE 0200                            at  drive.sect, dw  2   ; sector
    60                                      iend
    61                                  
    62                                      ; --- modules ---
    63                                      %include    "../modules/real/puts.s"
     1                              <1> ; void puts(int16 straddr)
     2                              <1> ; write str from head to '\0'
     3                              <1> 
     4                              <1> 
     5                              <1> puts:
     6                              <1> 
     7                              <1>     ; build stack frame
     8 000000C0 55                  <1>     push    bp
     9 000000C1 89E5                <1>     mov     bp, sp
    10                              <1> 
    11                              <1>     ; save registers
    12 000000C3 50                  <1>     push    ax
    13 000000C4 53                  <1>     push    bx
    14 000000C5 56                  <1>     push    si
    15                              <1> 
    16                              <1>     ; get arg
    17 000000C6 8B7604              <1>     mov     si, [bp + 4]    ; si = straddr
    18                              <1> 
    19                              <1>     ; write text in teletype mode
    20 000000C9 B40E                <1>     mov     ah, 0x0E
    21 000000CB BB0000              <1>     mov     bx, 0x00
    22 000000CE FC                  <1>     cld                     ; DF = 0    
    23                              <1> .10L:
    24 000000CF AC                  <1>     lodsb
    25 000000D0 3C00                <1>     cmp     al, 0           ; if (*(si++) == 0)
    26 000000D2 7404                <1>     je      .10E            ; break;
    27 000000D4 CD10                <1>     int     0x10
    28 000000D6 EBF7                <1>     jmp     .10L
    29                              <1> .10E:
    30                              <1> 
    31                              <1>     ; return registers
    32 000000D8 5E                  <1>     pop     si
    33 000000D9 5B                  <1>     pop     bx
    34 000000DA 58                  <1>     pop     ax
    35                              <1> 
    36                              <1>     ; destroy stack frame
    37 000000DB 89EC                <1>     mov     sp, bp
    38 000000DD 5D                  <1>     pop     bp
    39                              <1> 
    40 000000DE C3                  <1>     ret
    64                                      %include    "../modules/real/reboot.s"
     1                              <1> ; reboot
     2                              <1> 
     3                              <1> 
     4                              <1> reboot:
     5                              <1>     ; display a message
     6 000000DF 68[FB00]E8DBFF83C4- <1>     cdecl   puts, .s0
     6 000000E7 02                  <1>
     7                              <1> 
     8                              <1>     ; wait for key-input
     9                              <1> .10L:
    10 000000E8 B410                <1>     mov     ah, 0x10
    11 000000EA CD16                <1>     int     0x16            ; get key-input
    12                              <1> 
    13 000000EC 3C20                <1>     cmp     al, ' '
    14 000000EE 75F8                <1>     jne     .10L
    15                              <1> 
    16                              <1>     ; output newline
    17 000000F0 68[1901]E8CAFF83C4- <1>     cdecl   puts, .s1
    17 000000F8 02                  <1>
    18                              <1> 
    19                              <1>     ; reboot
    20 000000F9 CD19                <1>     int     0x19
    21                              <1> 
    22                              <1> 
    23 000000FB 0A0D50757368205350- <1> .s0:    db  0x0A, 0x0D, "Push SPACE key to reboot...", 0
    23 00000104 414345206B65792074- <1>
    23 0000010D 6F207265626F6F742E- <1>
    23 00000116 2E2E00              <1>
    24 00000119 0A0D0A0D00          <1> .s1:    db  0x0A, 0x0D, 0x0A, 0x0D, 0
    65                                      %include    "../modules/real/read_chs.s"
     1                              <1> ; int read_chs(int drive, int sect, int dst)
     2                              <1> ; return number of sectors read
     3                              <1> ; drive: addr to drive struct
     4                              <1> ; sect: number of read sectors
     5                              <1> ; dst: dst addr
     6                              <1> 
     7                              <1> ; can't call this func before DS = 0, maybe
     8                              <1> 
     9                              <1> 
    10                              <1> read_chs:
    11                              <1> 
    12                              <1>     ; build stack frame
    13 0000011E 55                  <1>     push    bp
    14 0000011F 89E5                <1>     mov     bp, sp
    15 00000121 6A03                <1>     push    3           ; number of retries
    16 00000123 6A00                <1>     push    0           ; number of sectors read
    17                              <1> 
    18                              <1>     ; save registers
    19 00000125 53                  <1>     push    bx
    20 00000126 51                  <1>     push    cx
    21 00000127 52                  <1>     push    dx
    22 00000128 06                  <1>     push    es
    23 00000129 56                  <1>     push    si
    24                              <1> 
    25                              <1>     ; set cx, dx, es, bx for reading sectors (CHS)
    26 0000012A 8B7604              <1>     mov     si, [bp + 4]                ; si = addr to drive struct
    27 0000012D 8A6C02              <1>     mov     ch, [si + drive.cyln] 
    28 00000130 8A4C03              <1>     mov     cl, [si + drive.cyln + 1]
    29 00000133 C0E106              <1>     shl     cl, 6
    30 00000136 0A4C06              <1>     or      cl, [si + drive.sect]
    31                              <1> 
    32 00000139 8A7404              <1>     mov     dh, [si + drive.head]
    33 0000013C 8A14                <1>     mov     dl, [si + 0]
    34                              <1> 
    35 0000013E B80000              <1>     mov     ax, 0
    36 00000141 8EC0                <1>     mov     es, ax
    37 00000143 8B5E08              <1>     mov     bx, [bp + 8]
    38                              <1> 
    39                              <1> .10L:
    40                              <1>     ; read sectors
    41 00000146 B402                <1>     mov     ah, 0x02
    42 00000148 8A4606              <1>     mov     al, [bp + 6]
    43                              <1> 
    44 0000014B CD13                <1>     int     0x13
    45 0000014D 7304                <1>     jnc      .11E        ; if error occured, jump to .11E
    46 0000014F B000                <1>     mov     al, 0
    47 00000151 EB0C                <1>     jmp     .10E
    48                              <1> 
    49                              <1> .11E:
    50 00000153 3C00                <1>     cmp     al, 0
    51 00000155 7508                <1>     jne     .10E        ; if at least one sector was read
    52                              <1> 
    53 00000157 B80000              <1>     mov     ax, 0
    54 0000015A FF4EFE              <1>     dec     word    [bp - 2]    ; retry--
    55 0000015D 75E7                <1>     jnz     .10L                ; read sectors again
    56                              <1> 
    57                              <1> .10E:
    58                              <1>     ; remove status info
    59 0000015F B400                <1>     mov     ah, 0
    60                              <1> 
    61                              <1>     ; return registers
    62 00000161 5E                  <1>     pop     si
    63 00000162 07                  <1>     pop     es
    64 00000163 5A                  <1>     pop     dx
    65 00000164 59                  <1>     pop     cx
    66 00000165 5B                  <1>     pop     bx
    67                              <1> 
    68                              <1>     ; destroy stack frame
    69 00000166 89EC                <1>     mov     sp, bp
    70 00000168 5D                  <1>     pop     bp
    71                              <1> 
    72 00000169 C3                  <1>     ret
    66                                  
    67                                  
    68                                      ; --- boot flag ---
    69 0000016A 00<rept>                    times   510 - ($ - $$) db 0x00
    70 000001FE 55AA                        db      0x55, 0xAA              ; boot flag
    71                                  
    72                                  
    73                                      ; ----------------------------
    74                                      ; informations obtained in real mode
    75                                      ; ----------------------------
    76                                  
    77                                      ; BIOS font data addr
    78                                  FONT:
    79 00000200 0000                    .seg    dw  0
    80 00000202 0000                    .off    dw  0
    81                                      ; ACPI data address 
    82                                  ACPI_DATA:
    83 00000204 00000000                .adr:   dd  0
    84 00000208 00000000                .len:   dd  0
    85                                  
    86                                      ; ----------------------------
    87                                      ; --- 2nd stage of booting ---
    88                                      ; ----------------------------
    89                                  
    90                                      ; --- modules ---
    91                                      %include    "../modules/real/putc.s"
     1                              <1> ; void putc(int16 chcode)
     2                              <1> 
     3                              <1> putc:
     4                              <1> 
     5                              <1>     ; build stack frame
     6 0000020C 55                  <1>     push    bp
     7 0000020D 89E5                <1>     mov     bp, sp
     8                              <1> 
     9                              <1>     ; save registers
    10 0000020F 50                  <1>     push    ax
    11 00000210 53                  <1>     push    bx
    12                              <1> 
    13                              <1> 
    14                              <1>     ; write text in teletype mode
    15 00000211 8A4604              <1>     mov     al, [bp + 4]
    16 00000214 B40E                <1>     mov     ah, 0x0E
    17 00000216 BB0000              <1>     mov     bx, 0x00
    18 00000219 CD10                <1>     int     0x10
    19                              <1> 
    20                              <1> 
    21                              <1>     ; return registers
    22 0000021B 5B                  <1>     pop     bx
    23 0000021C 58                  <1>     pop     ax
    24                              <1> 
    25                              <1>     ; destroy stack frame
    26 0000021D 89EC                <1>     mov     sp, bp
    27 0000021F 5D                  <1>     pop     bp
    28                              <1> 
    29 00000220 C3                  <1>     ret
    92                                      %include    "../modules/real/itoa.s"
     1                              <1> ; void itos(int num, char* buf, int size, int radix, int flags);
     2                              <1> ; flags = 1 : num is used as signed
     3                              <1> ; flags = 2 : display plus/minus sign
     4                              <1> ; flags = 4 : fill in the space with 0
     5                              <1> 
     6                              <1> 
     7                              <1> itoa:
     8                              <1>     ; build stack frame
     9 00000221 55                  <1>     push    bp
    10 00000222 89E5                <1>     mov     bp, sp
    11                              <1> 
    12                              <1>     ; save registers' data
    13 00000224 50                  <1>     push    ax
    14 00000225 53                  <1>     push    bx
    15 00000226 51                  <1>     push    cx
    16 00000227 52                  <1>     push    dx
    17 00000228 56                  <1>     push    si
    18 00000229 57                  <1>     push    di
    19                              <1> 
    20                              <1>     ; get args
    21 0000022A 8B4604              <1>     mov     ax, [bp + 4]    ; ax = num;
    22 0000022D 8B7606              <1>     mov     si, [bp + 6]    ; si = buf;
    23 00000230 8B4E08              <1>     mov     cx, [bp + 8]    ; cx = size;
    24                              <1> 
    25 00000233 89F7                <1>     mov     di, si
    26 00000235 01CF                <1>     add     di, cx
    27 00000237 4F                  <1>     dec     di              ; di = &(buf[size - 1]);
    28                              <1> 
    29 00000238 8B5E0C              <1>     mov     bx, [bp + 12]   ; bx = flags;
    30                              <1> 
    31                              <1>     ; positive/negative judgement
    32 0000023B F7C30100            <1>     test    bx, 0b0001      ; if (flags & 0x01)
    33 0000023F 7408                <1>     je      .10E
    34 00000241 83F800              <1>     cmp     ax, 0           ;   if (num < 0)
    35 00000244 7D03                <1>     jge     .12E
    36 00000246 83CB02              <1>     or      bx, 0b0010      ;       flags |= 2;
    37                              <1> .10E:
    38                              <1> .12E:
    39                              <1> 
    40                              <1>     ; which sould be displayed pos/neg ?
    41 00000249 F7C30200            <1>     test    bx, 0b0010
    42 0000024D 7410                <1>     je      .20E
    43 0000024F 83F800              <1>     cmp     ax, 0
    44 00000252 7D07                <1>     jge     .22F
    45 00000254 F7D8                <1>     neg     ax              ; num *= -1;
    46 00000256 C6042D              <1>     mov     [si], byte '-'  ; buf[0] = '-';
    47 00000259 EB03                <1>     jmp     .22E
    48                              <1> .22F:
    49 0000025B C6042B              <1>     mov     [si], byte '+'
    50                              <1> .22E:
    51 0000025E 49                  <1>     dec     cx
    52                              <1> .20E:
    53                              <1> 
    54                              <1> 
    55                              <1>     ; convert num to ASCII
    56 0000025F 8B5E0A              <1>     mov     bx, [bp + 10]           ; bx = radix
    57                              <1> .30L:
    58 00000262 BA0000              <1>     mov     dx, 0
    59 00000265 F7F3                <1>     div     bx                      ; ax = dx:ax % bx,;     dx = dx:ax % bx;
    60                              <1> 
    61 00000267 89D6                <1>     mov     si, dx
    62 00000269 8A94[9202]          <1>     mov     dl, byte [.ascii + si]  ; dl = ascii[si];
    63                              <1> 
    64 0000026D 8815                <1>     mov     [di], dl                ; buf[size - i]
    65 0000026F 4F                  <1>     dec     di
    66                              <1> 
    67 00000270 83F800              <1>     cmp     ax, 0
    68 00000273 E0ED                <1>     loopnz  .30L
    69                              <1> 
    70                              <1> 
    71                              <1>     ; fill in the space
    72 00000275 83F900              <1>     cmp     cx, 0
    73 00000278 740E                <1>     je      .40E
    74 0000027A B020                <1>     mov     al, ' '
    75 0000027C F7460C0400          <1>     test    [bp + 12], word 0b0100  ; if (flags & 0x04)
    76 00000281 7402                <1>     je     .42E
    77 00000283 B030                <1>     mov     al, '0'
    78                              <1> .42E:
    79 00000285 FD                  <1>     std                             ; DF = 1 (- direction)
    80 00000286 F3AA                <1>     rep stosb                       ; while(--cx) [di--] = al;
    81                              <1> .40E:
    82                              <1> 
    83                              <1> 
    84                              <1>     ; return registers' data
    85 00000288 5F                  <1>     pop     di
    86 00000289 5E                  <1>     pop     si
    87 0000028A 5A                  <1>     pop     dx
    88 0000028B 59                  <1>     pop     cx
    89 0000028C 5B                  <1>     pop     bx
    90 0000028D 58                  <1>     pop     ax
    91                              <1> 
    92                              <1>     ; destroy stack frame
    93 0000028E 89EC                <1>     mov     sp, bp
    94 00000290 5D                  <1>     pop     bp
    95                              <1> 
    96 00000291 C3                  <1>     ret
    97                              <1> 
    98                              <1> 
    99 00000292 303132333435363738- <1> .ascii: db  "0123456789ABCDEF"      ; ascii-short table
    99 0000029B 39414243444546      <1>
   100                              <1> 
    93                                      %include    "../modules/real/get_drive_params.s"
     1                              <1> ; int get_drive_param(int drive)
     2                              <1> 
     3                              <1> ; set maximam accessible number of sectors, cylinders and heads coressponding drive number
     4                              <1> 
     5                              <1> ; drive: addr to drive struct
     6                              <1> ; return non-zero on success, and 0 on error 
     7                              <1> 
     8                              <1> 
     9                              <1> get_drive_params:
    10                              <1> 
    11                              <1>     ; build stack frame
    12 000002A2 55                  <1>     push    bp
    13 000002A3 89E5                <1>     mov     bp, sp
    14                              <1> 
    15                              <1>     ; save registers
    16 000002A5 53                  <1>     push    bx
    17 000002A6 51                  <1>     push    cx
    18 000002A7 06                  <1>     push    es
    19 000002A8 56                  <1>     push    si
    20 000002A9 57                  <1>     push    di
    21                              <1> 
    22                              <1>     
    23 000002AA 8B7604              <1>     mov     si, [bp + 4]                ; si = addr to drive struct
    24                              <1> 
    25                              <1>     ; initialize Disk Base Table pointer
    26 000002AD B80000              <1>     mov     ax, 0
    27 000002B0 8EC0                <1>     mov     es, ax
    28 000002B2 89C7                <1>     mov     di, ax
    29                              <1> 
    30                              <1>     ; get current drive parameters
    31 000002B4 B408                <1>     mov     ah, 8
    32 000002B6 8A14                <1>     mov     dl, [si + drive.no]
    33 000002B8 CD13                <1>     int     0x13
    34 000002BA 721A                <1>     jc      .10F
    35                              <1>     ; success
    36 000002BC 88C8                <1>     mov     al, cl
    37 000002BE 243F                <1>     and     al, 0x3F        ; ax = number of sectors
    38                              <1> 
    39 000002C0 C0E906              <1>     shr     cl, 6
    40 000002C3 C1C908              <1>     ror     cx, 8
    41 000002C6 41                  <1>     inc     cx              ; cx = number of cylinders
    42                              <1> 
    43 000002C7 0FB6DE              <1>     movzx   bx, dh
    44 000002CA 43                  <1>     inc     bx              ; bx = number of heads
    45                              <1> 
    46 000002CB 894406              <1>     mov     [si + drive.sect], ax
    47 000002CE 894C02              <1>     mov     [si + drive.cyln], cx
    48 000002D1 895C04              <1>     mov     [si + drive.head], bx
    49                              <1> 
    50 000002D4 EB03                <1>     jmp     .10E
    51                              <1>     ; error
    52                              <1> .10F:
    53 000002D6 B80000              <1>     mov     ax, 0
    54                              <1> 
    55                              <1> 
    56                              <1> .10E:
    57                              <1>     ; return registers
    58 000002D9 5F                  <1>     pop     di
    59 000002DA 5E                  <1>     pop     si
    60 000002DB 07                  <1>     pop     es
    61 000002DC 59                  <1>     pop     cx
    62 000002DD 5B                  <1>     pop     bx
    63                              <1> 
    64                              <1>     ; destroy stack frame
    65 000002DE 89EC                <1>     mov     sp, bp
    66 000002E0 5D                  <1>     pop     bp
    67                              <1> 
    68 000002E1 C3                  <1>     ret
    94                                      %include    "../modules/real/get_font_adr.s"
     1                              <1> ; void get_font_adr(long adr);
     2                              <1> ; adr = addr to BIOS font data
     3                              <1> 
     4                              <1> get_font_data:
     5                              <1> 
     6                              <1>     ; build stack frame
     7 000002E2 55                  <1>     push    bp
     8 000002E3 89E5                <1>     mov     bp, sp
     9                              <1> 
    10                              <1>     ; save registers
    11 000002E5 50                  <1>     push    ax
    12 000002E6 53                  <1>     push    bx
    13 000002E7 56                  <1>     push    si
    14 000002E8 06                  <1>     push    es
    15 000002E9 55                  <1>     push    bp
    16                              <1> 
    17                              <1>     ; get the arg
    18 000002EA 8B7604              <1>     mov     si, [bp + 4]
    19                              <1>     
    20                              <1>     ; get BIOS font addr
    21 000002ED B83011              <1>     mov     ax, 0x1130      ; get current character generator information
    22 000002F0 B706                <1>     mov     bh, 0x06        ; 8x16 character
    23 000002F2 CD10                <1>     int     10h             ; ES:BP = font addr
    24                              <1> 
    25                              <1>     ; save font address
    26 000002F4 8C04                <1>     mov     [si + 0], es    ; segment
    27 000002F6 896C02              <1>     mov     [si + 2], bp    ; offset
    28                              <1> 
    29                              <1>     ; return registers
    30 000002F9 5D                  <1>     pop     bp
    31 000002FA 07                  <1>     pop     es
    32 000002FB 5E                  <1>     pop     si
    33 000002FC 5B                  <1>     pop     bx
    34 000002FD 58                  <1>     pop     ax
    35                              <1> 
    36                              <1>     ; destroy stack frame
    37 000002FE 89EC                <1>     mov     sp, bp
    38 00000300 5D                  <1>     pop     bp
    39                              <1> 
    40 00000301 C3                  <1>     ret
    95                                  
    96                                  stage_2:
    97 00000302 68[7D03]E8B8FD83C4-         cdecl   puts, .s0               ; display a message
    97 0000030A 02                 
    98                                  
    99                                      ; get drive params
   100 0000030B 68[B800]E891FF83C4-         cdecl   get_drive_params, BOOT
   100 00000313 02                 
   101 00000314 83F800                      cmp     ax, 0
   102 00000317 750C                        jne     .10E
   103 00000319 68[B403]E8A1FD83C4-         cdecl   puts, .e0               ; display an error message
   103 00000321 02                 
   104 00000322 E8BAFD                      call    reboot
   105                                  .10E:
   106                                      ; display information of drive params
   107 00000325 A1[B800]                    mov     ax, [BOOT + drive.no]
   108 00000328 6A046A106A0268-             cdecl   itoa, ax, .p1, 2, 16, 0b0100
   108 0000032F [9503]50E8ECFE83C4-
   108 00000337 0A                 
   109 00000338 A1[BA00]                    mov     ax, [BOOT + drive.cyln]
   110 0000033B 6A046A106A0468-             cdecl   itoa, ax, .p2, 4, 16, 0b0100
   110 00000342 [9D03]50E8D9FE83C4-
   110 0000034A 0A                 
   111 0000034B A1[BC00]                    mov     ax, [BOOT + drive.head]
   112 0000034E 6A046A106A0268-             cdecl   itoa, ax, .p3, 2, 16, 0b0100
   112 00000355 [A703]50E8C6FE83C4-
   112 0000035D 0A                 
   113 0000035E A1[BE00]                    mov     ax, [BOOT + drive.sect]
   114 00000361 6A046A106A0268-             cdecl   itoa, ax, .p4, 2, 16, 0b0100
   114 00000368 [AF03]50E8B3FE83C4-
   114 00000370 0A                 
   115 00000371 68[8C03]E849FD83C4-         cdecl   puts, .s1                       ; puts(.s1 ~ .p4)
   115 00000379 02                 
   116                                  
   117                                      ; transition to the 3rd stage
   118 0000037A E9FF02                      jmp     stage_3rd
   119                                  
   120 0000037D 326E64207374616765-     .s0:    db  "2nd stage...", 0x0A, 0x0D, 0
   120 00000386 2E2E2E0A0D00       
   121                                  
   122 0000038C 2044726976653A3078      .s1:    db  " Drive:0x"
   123 00000395 20202C20433A3078        .p1:    db  "  , C:0x"
   124 0000039D 202020202C20483A30-     .p2:    db  "    , H:0x"
   124 000003A6 78                 
   125 000003A7 20202C20533A3078        .p3:    db  "  , S:0x"
   126 000003AF 20200A0D00              .p4:    db  "  ", 0x0A, 0x0D, 0
   127                                  
   128 000003B4 43616E277420676574-     .e0:    db  "Can't get drive parameter.", 0
   128 000003BD 206472697665207061-
   128 000003C6 72616D657465722E00 
   129                                  
   130                                  
   131                                      ; ----------------------------
   132                                      ; --- 3rd stage of booting ---
   133                                      ; ----------------------------
   134                                  
   135                                      ; --- modules ---
   136                                      %include    "../modules/real/get_mem_info.s"
     1                              <1> ; void get_mem_info(void)
     2                              <1> ; get mem info using INT 0x15, EAX = 0xE820, and store ACPI info in ACPI_DATA in the global area
     3                              <1> 
     4                              <1> 
     5                              <1> get_mem_info:
     6                              <1> 
     7                              <1>     ; save registers
     8 000003CF 6650                <1>     push    eax
     9 000003D1 6653                <1>     push    ebx
    10 000003D3 6651                <1>     push    ecx
    11 000003D5 6652                <1>     push    edx
    12 000003D7 56                  <1>     push    si
    13 000003D8 57                  <1>     push    di
    14 000003D9 55                  <1>     push    bp
    15                              <1> 
    16 000003DA 68[6E04]E8E0FC83C4- <1>     cdecl   puts, .s0
    16 000003E2 02                  <1>
    17 000003E3 BD0000              <1>     mov     bp, 0                       ; line = 0;
    18 000003E6 66BB00000000        <1>     mov     ebx, 0                      ; continuation value or zero to start at beginning of map
    19                              <1> .10L:                                                                                   ; do {
    20 000003EC 66B820E80000        <1>     mov     eax, 0xE820
    21 000003F2 66B914000000        <1>     mov     ecx, E820_RECORD_SIZE       ; size of buffer for result, in bytes
    22 000003F8 66BA50414D53        <1>     mov     edx, 'PAMS'                 ; edx = 'SMAP'
    23 000003FE BF[F804]            <1>     mov     di, .b0                     ; ES:DI -> buffer for result
    24 00000401 CD15                <1>     int     0x15                        ; Newer BIOSes - GET SYSTEM MEMORY MAP
    25                              <1> 
    26                              <1>     ; Is the BIOS support this interrupt service?
    27 00000403 663D50414D53        <1>     cmp     eax, 'PAMS'
    28 00000409 7402                <1>     je      .12E
    29 0000040B EB4C                <1>     jmp     .10E
    30                              <1> .12E:
    31                              <1>     ; error check
    32 0000040D 7302                <1>     jnc     .14E
    33 0000040F EB48                <1>     jmp     .10E
    34                              <1> 
    35                              <1> .14E:
    36 00000411 57E8F70083C402      <1>     cdecl   put_mem_info, di            ; display mem info of one record
    37                              <1> 
    38                              <1>     ; get addrs of ACPI data 
    39 00000418 668B4510            <1>     mov     eax, [di + 16]              ; eax = data type
    40 0000041C 6683F803            <1>     cmp     eax, 3                      ; Is data type ACPI Reclaim Memory?
    41 00000420 750F                <1>     jne     .15E
    42                              <1> 
    43 00000422 668B05              <1>     mov     eax, [di + 0]
    44 00000425 66A3[0402]          <1>     mov     [ACPI_DATA.adr], eax        ; base addr
    45                              <1> 
    46 00000429 668B4508            <1>     mov     eax, [di + 8]
    47 0000042D 66A3[0802]          <1>     mov     [ACPI_DATA.len], eax        ; length
    48                              <1> 
    49                              <1> .15E:
    50                              <1>     ; display a message per 8 lines to prevent the screen from being refleshed
    51 00000431 6683FB00            <1>     cmp     ebx, 0                      ; all done?
    52 00000435 741C                <1>     jz      .16E
    53                              <1> 
    54 00000437 45                  <1>     inc     bp                          ; line++;
    55 00000438 83E507              <1>     and     bp, 0x07
    56 0000043B 7516                <1>     jnz     .16E
    57                              <1>     ; display a message
    58 0000043D 68[E104]E87DFC83C4- <1>     cdecl   puts, .s2
    58 00000445 02                  <1>
    59                              <1> 
    60 00000446 B410                <1>     mov     ah, 0x10
    61 00000448 CD16                <1>     int     0x16                        ; waiting for key-in
    62                              <1> 
    63 0000044A 68[EC04]E870FC83C4- <1>     cdecl   puts, .s3                   ; remove the message 
    63 00000452 02                  <1>
    64                              <1> 
    65                              <1> .16E:
    66 00000453 6683FB00            <1>     cmp     ebx, 0
    67 00000457 7593                <1>     jne     .10L                                                                                ; } while(0 != ebx)
    68                              <1> 
    69                              <1> 
    70                              <1> .10E:
    71 00000459 68[B104]E861FC83C4- <1>     cdecl   puts, .s1
    71 00000461 02                  <1>
    72                              <1> 
    73                              <1>     ; return registers
    74 00000462 5D                  <1>     pop     bp
    75 00000463 5F                  <1>     pop     di
    76 00000464 5E                  <1>     pop     si
    77 00000465 665A                <1>     pop     edx
    78 00000467 6659                <1>     pop     ecx
    79 00000469 665B                <1>     pop     ebx
    80 0000046B 6658                <1>     pop     eax
    81                              <1> 
    82                              <1> 
    83 0000046D C3                  <1>     ret
    84                              <1> 
    85                              <1> 
    86 0000046E 2045383230204D656D- <1> .s0:	db " E820 Memory Map:", 0x0A, 0x0D
    86 00000477 6F7279204D61703A0A- <1>
    86 00000480 0D                  <1>
    87 00000481 20426173655F5F5F5F- <1> 		db " Base_____________ Length___________ Type____", 0x0A, 0x0D, 0
    87 0000048A 5F5F5F5F5F5F5F5F5F- <1>
    87 00000493 204C656E6774685F5F- <1>
    87 0000049C 5F5F5F5F5F5F5F5F5F- <1>
    87 000004A5 20547970655F5F5F5F- <1>
    87 000004AE 0A0D00              <1>
    88 000004B1 202D2D2D2D2D2D2D2D- <1> .s1:	db " ----------------- ----------------- --------", 0x0A, 0x0D, 0
    88 000004BA 2D2D2D2D2D2D2D2D2D- <1>
    88 000004C3 202D2D2D2D2D2D2D2D- <1>
    88 000004CC 2D2D2D2D2D2D2D2D2D- <1>
    88 000004D5 202D2D2D2D2D2D2D2D- <1>
    88 000004DE 0A0D00              <1>
    89 000004E1 203C6D6F72652E2E2E- <1> .s2:    db  " <more...>", 0
    89 000004EA 3E00                <1>
    90 000004EC 0D2020202020202020- <1> .s3:    db  0x0D, "        ", 0x0D, 0
    90 000004F5 0D00                <1>
    91                              <1> 
    92 000004F7 00                  <1> ALIGN 4,    db  0
    93 000004F8 00<rept>            <1> .b0:    times   E820_RECORD_SIZE    db  0   ; system memmap buffer
    94                              <1> 
    95                              <1> 
    96                              <1> ; void put_mem_info(int16 addr)
    97                              <1> ; nested func
    98                              <1> 
    99                              <1> put_mem_info:
   100                              <1> 
   101                              <1>     ; build stack frame
   102 0000050C 55                  <1>     push    bp
   103 0000050D 89E5                <1>     mov     bp, sp
   104                              <1> 
   105                              <1>     ; save registers
   106 0000050F 53                  <1>     push    bx
   107 00000510 56                  <1>     push    si
   108                              <1> 
   109                              <1>     ; get addr
   110 00000511 8B7604              <1>     mov     si, [bp + 4]
   111                              <1> 
   112                              <1>     ; convert mem info from int to str
   113                              <1>     ; Base(64bit)
   114 00000514 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 6], .s2 + 0, 4, 16, 0b0100
   114 0000051B [EB05]FF7406E8FEFC- <1>
   114 00000523 83C40A              <1>
   115 00000526 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 4], .s2 + 4, 4, 16, 0b0100
   115 0000052D [EF05]FF7404E8ECFC- <1>
   115 00000535 83C40A              <1>
   116 00000538 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 2], .s3 + 0, 4, 16, 0b0100
   116 0000053F [F405]FF7402E8DAFC- <1>
   116 00000547 83C40A              <1>
   117 0000054A 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 0], .s3 + 4, 4, 16, 0b0100
   117 00000551 [F805]FF34E8C9FC83- <1>
   117 00000559 C40A                <1>
   118                              <1>     ; Length(64bit)
   119 0000055B 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 14], .s4 + 0, 4, 16, 0b0100
   119 00000562 [FD05]FF740EE8B7FC- <1>
   119 0000056A 83C40A              <1>
   120 0000056D 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 12], .s4 + 4, 4, 16, 0b0100
   120 00000574 [0106]FF740CE8A5FC- <1>
   120 0000057C 83C40A              <1>
   121 0000057F 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 10], .s5 + 0, 4, 16, 0b0100
   121 00000586 [0606]FF740AE893FC- <1>
   121 0000058E 83C40A              <1>
   122 00000591 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 8],  .s5 + 4, 4, 16, 0b0100
   122 00000598 [0A06]FF7408E881FC- <1>
   122 000005A0 83C40A              <1>
   123                              <1>     ; Type(32bit)
   124 000005A3 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 18], .s6 + 0, 4, 16, 0b0100
   124 000005AA [0F06]FF7412E86FFC- <1>
   124 000005B2 83C40A              <1>
   125 000005B5 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 16], .s6 + 4, 4, 16, 0b0100
   125 000005BC [1306]FF7410E85DFC- <1>
   125 000005C4 83C40A              <1>
   126                              <1> 
   127 000005C7 68[EA05]E8F3FA83C4- <1>     cdecl   puts, .s1   ; display mem info(Base, Length)
   127 000005CF 02                  <1>
   128                              <1> 
   129 000005D0 8B5C10              <1>     mov     bx, [si + 16]
   130 000005D3 83E307              <1>     and     bx, 0x07            ; bx = type 0 ~ 5;
   131 000005D6 D1E3                <1>     shl     bx, 1               ; bx *= 2;
   132 000005D8 81C3[6C06]          <1>     add     bx, .tpstrlist      ; bx += .tpstrlist
   133 000005DC FF37E8DFFA83C402    <1>     cdecl   puts, word [bx]
   134                              <1> 
   135                              <1> 
   136                              <1>     ; return registers
   137 000005E4 5E                  <1>     pop     si
   138 000005E5 5B                  <1>     pop     bx
   139                              <1> 
   140                              <1>     ; destroy stack frame
   141 000005E6 89EC                <1>     mov     sp, bp
   142 000005E8 5D                  <1>     pop     bp
   143                              <1> 
   144 000005E9 C3                  <1>     ret
   145                              <1> 
   146                              <1> 
   147 000005EA 20                  <1> .s1:    db  " "
   148 000005EB 5A5A5A5A5A5A5A5A5F  <1> .s2:    db  "ZZZZZZZZ_"
   149 000005F4 5A5A5A5A5A5A5A5A20  <1> .s3:    db  "ZZZZZZZZ "
   150 000005FD 5A5A5A5A5A5A5A5A5F  <1> .s4:    db  "ZZZZZZZZ_"
   151 00000606 5A5A5A5A5A5A5A5A20  <1> .s5:    db  "ZZZZZZZZ "
   152 0000060F 5A5A5A5A5A5A5A5A00  <1> .s6:    db  "ZZZZZZZZ", 0
   153                              <1> 
   154 00000618 2028556E6B6E6F776E- <1> .t0:    db  " (Unknown)", 0x0A, 0x0D, 0
   154 00000621 290A0D00            <1>
   155 00000625 2028757361626C6529- <1> .t1:    db  " (usable)", 0x0A, 0x0D, 0
   155 0000062E 0A0D00              <1>
   156 00000631 202872657365727665- <1> .t2:    db  " (reserved)", 0x0A, 0x0D, 0
   156 0000063A 64290A0D00          <1>
   157 0000063F 202841435049206461- <1> .t3:    db  " (ACPI data)", 0x0A, 0x0D, 0
   157 00000648 7461290A0D00        <1>
   158 0000064E 202841435049204E56- <1> .t4:    db  " (ACPI NVS)", 0x0A, 0x0D, 0
   158 00000657 53290A0D00          <1>
   159 0000065C 2028626164206D656D- <1> .t5:    db  " (bad memory)", 0x0A, 0x0D, 0
   159 00000665 6F7279290A0D00      <1>
   160                              <1> 
   161 0000066C [1806][2506][3106]- <1> .tpstrlist: dw  .t0, .t1, .t2, .t3, .t4, .t5, .t0, .t0      ; each of these addresses is 16bit(real mode)
   161 00000672 [3F06][4E06][5C06]- <1>
   161 00000678 [1806][1806]        <1>
   137                                  
   138                                  stage_3rd:
   139 0000067C 68[FA06]E83EFA83C4-         cdecl   puts, .s0               ; display a message
   139 00000684 02                 
   140                                  
   141                                      ; get BIOS font data
   142 00000685 68[0002]E857FC83C4-         cdecl   get_font_data, FONT
   142 0000068D 02                 
   143                                  
   144                                      ; display font addr
   145 0000068E 6A046A106A0468-             cdecl   itoa, word[FONT.seg], .p1, 4, 16, 0b0100
   145 00000695 [1707]FF36[0002]E8-
   145 0000069C 83FB83C40A         
   146 000006A1 6A046A106A0468-             cdecl   itoa, word[FONT.off], .p2, 4, 16, 0b0100
   146 000006A8 [1C07]FF36[0202]E8-
   146 000006AF 70FB83C40A         
   147 000006B4 68[0907]E806FA83C4-         cdecl   puts, .s1
   147 000006BC 02                 
   148                                  
   149                                      ; display mem info
   150 000006BD E80FFD                      cdecl   get_mem_info
   151                                  
   152 000006C0 66A1[0402]                  mov     eax, [ACPI_DATA.adr]    ; 32bit
   153 000006C4 6683F800                    cmp     eax, 0
   154 000006C8 742D                        je      .10E
   155 000006CA 6A046A106A0468-             cdecl   itoa, ax, .p4, 4, 16, 0b0100
   155 000006D1 [3407]50E84AFB83C4-
   155 000006D9 0A                 
   156 000006DA 66C1E810                    shr     eax, 16
   157 000006DE 6A046A106A0468-             cdecl   itoa, ax, .p3, 4, 16, 0b0100
   157 000006E5 [3007]50E836FB83C4-
   157 000006ED 0A                 
   158                                  
   159 000006EE 68[2507]E8CCF983C4-         cdecl   puts, .s2
   159 000006F6 02                 
   160                                  
   161                                  .10E:
   162                                      ; transition to the 4th stage
   163 000006F7 E9A100                      jmp     stage_4
   164                                  
   165                                  
   166 000006FA 337264207374616765-     .s0:    db  "3rd stage...", 0x0A, 0x0D, 0
   166 00000703 2E2E2E0A0D00       
   167 00000709 20466F6E7420416464-     .s1:    db  " Font Address="
   167 00000712 726573733D         
   168 00000717 5A5A5A5A3A              .p1:    db  "ZZZZ:"
   169 0000071C 5A5A5A5A0A0D            .p2:    db  "ZZZZ", 0x0A, 0x0D
   170 00000722 0A0D00                          db  0x0A, 0x0D, 0
   171                                  
   172 00000725 204143504920646174-     .s2:    db  " ACPI data="
   172 0000072E 613D               
   173 00000730 5A5A5A5A                .p3:    db  "ZZZZ"
   174 00000734 5A5A5A5A0A0D00          .p4:    db  "ZZZZ", 0x0A, 0x0D, 0
   175                                  
   176                                      ; ----------------------------
   177                                      ; --- 4th stage of booting ---
   178                                      ; ----------------------------
   179                                  
   180                                      ; --- modules ---
   181                                      %include    "../modules/real/kbc.s"
     1                              <1> ; definitions of
     2                              <1> ; int16 KBC_Data_Write(int16 input_data),
     3                              <1> ; int16 KBC_Data_Read(int16 output_adr),
     4                              <1> ; int16 KBC_Cmd_Write(int16 cmd)
     5                              <1> 
     6                              <1> ; --------------------------------------
     7                              <1> ; int16 KBC_Data_Write(int16 input_data)
     8                              <1> ; return non-zero on success, and 0 on error 
     9                              <1> ; input_data : input_data for the buffer in KBC
    10                              <1> 
    11                              <1> 
    12                              <1> KBC_Data_Write:
    13                              <1> 
    14                              <1>     ; build stack frame
    15 0000073B 55                  <1>     push    bp
    16 0000073C 89E5                <1>     mov     bp, sp
    17                              <1> 
    18                              <1>     ; save registers
    19 0000073E 51                  <1>     push    cx
    20                              <1> 
    21 0000073F B90000              <1>     mov     cx, 0           ; cnt = 0;
    22                              <1> .10L:                       ; do {
    23 00000742 E464                <1>     in      al, 0x64            ; get KBC status
    24                              <1> 
    25 00000744 A802                <1>     test    al, 0x02            ; check input buffer status
    26                              <1>                                 ; must be clear before attempting to write data to IO port 0x60 or IO port 0x64
    27 00000746 E0FA                <1>     loopnz  .10L            ; } while (--CX && !ZF);
    28                              <1> 
    29 00000748 83F900              <1>     cmp     cx, 0           ; if cnt == 0 again, it means time-out
    30 0000074B 7405                <1>     jz      .20E            ; if (CX) {
    31 0000074D 8A4604              <1>     mov     al, [bp + 4]        ; AL = input_data;
    32 00000750 E660                <1>     out     0x60, al            ; outp(0x60, AL);
    33                              <1>                             ; }
    34                              <1> 
    35                              <1> .20E:
    36 00000752 89C8                <1>     mov     ax, cx          ; return CX;
    37                              <1> 
    38                              <1>     ; return registers
    39 00000754 59                  <1>     pop     cx
    40                              <1> 
    41                              <1>     ; destroy stack frame
    42 00000755 89EC                <1>     mov     sp, bp
    43 00000757 5D                  <1>     pop     bp
    44                              <1> 
    45 00000758 C3                  <1>     ret
    46                              <1> 
    47                              <1> 
    48                              <1> ; -----------------------------------
    49                              <1> ; int16 KBC_Data_Read(int16 output_adr)
    50                              <1> ; return non-zero on success, and 0 on error 
    51                              <1> ; output_adr : adr for the data read from KBC buffer
    52                              <1> 
    53                              <1> KBC_Data_Read:
    54                              <1> 
    55                              <1>     ; build stack frame
    56 00000759 55                  <1>     push    bp
    57 0000075A 89E5                <1>     mov     bp, sp
    58                              <1> 
    59                              <1>     ; save registers
    60 0000075C 51                  <1>     push    cx
    61 0000075D 57                  <1>     push    di
    62                              <1> 
    63 0000075E B90000              <1>     mov     cx, 0           ; cnt = 0;
    64                              <1> .10L:                       ; do {
    65 00000761 E464                <1>     in      al, 0x64            ; get KBC status
    66                              <1> 
    67 00000763 A801                <1>     test    al, 0x01            ; check output buffer status
    68                              <1>                                 ; must be set before attempting to read data from IO port 0x60
    69 00000765 E1FA                <1>     loopz   .10L            ; } while (--CX && ZF);
    70                              <1> 
    71 00000767 83F900              <1>     cmp     cx, 0           ; if cnt == 0 again, it means time-out
    72 0000076A 7409                <1>     jz      .20E            ; if (CX) {
    73 0000076C B400                <1>     mov     ah, 0x00
    74 0000076E E460                <1>     in      al, 0x60            ; AL = inp(0x60);
    75                              <1>     
    76 00000770 8B7E04              <1>     mov     di, [bp + 4]        ; DI = output_adr;
    77 00000773 8905                <1>     mov     [di + 0], ax        ; *DI = AX;
    78                              <1>                             ; }
    79                              <1> 
    80                              <1> .20E:
    81 00000775 89C8                <1>     mov     ax, cx          ; return CX;
    82                              <1> 
    83                              <1>     ; return registers
    84 00000777 5F                  <1>     pop     di
    85 00000778 59                  <1>     pop     cx
    86                              <1> 
    87                              <1>     ; destroy stack frame
    88 00000779 89EC                <1>     mov     sp, bp
    89 0000077B 5D                  <1>     pop     bp
    90                              <1> 
    91 0000077C C3                  <1>     ret
    92                              <1> 
    93                              <1> 
    94                              <1> ; ------------------------------
    95                              <1> ; int16 KBC_Cmd_Write(int16 cmd)
    96                              <1> ; return non-zero on success, and 0 on error 
    97                              <1> ; cmd : command sending to KBC
    98                              <1> 
    99                              <1> KBC_Cmd_Write:
   100                              <1> 
   101                              <1>     ; build stack frame
   102 0000077D 55                  <1>     push    bp
   103 0000077E 89E5                <1>     mov     bp, sp
   104                              <1> 
   105                              <1>     ; save registers
   106 00000780 51                  <1>     push    cx
   107                              <1> 
   108 00000781 B90000              <1>     mov     cx, 0           ; cnt = 0;
   109                              <1> .10L:                       ; do {
   110 00000784 E464                <1>     in      al, 0x64            ; get KBC status
   111                              <1> 
   112 00000786 A802                <1>     test    al, 0x02            ; check input buffer status
   113                              <1>                                 ; must be clear before attempting to write data to IO port 0x60 or IO port 0x64
   114 00000788 E0FA                <1>     loopnz  .10L            ; } while (--CX && !ZF);
   115                              <1> 
   116 0000078A 83F900              <1>     cmp     cx, 0           ; if cnt == 0 again, it means time-out
   117 0000078D 7405                <1>     jz      .20E            ; if (CX) {
   118 0000078F 8A4604              <1>     mov     al, [bp + 4]        ; AL = input_data;
   119 00000792 E664                <1>     out     0x64, al            ; outp(0x60, AL);
   120                              <1>                             ; }
   121                              <1> 
   122                              <1> .20E:
   123 00000794 89C8                <1>     mov     ax, cx          ; return CX;
   124                              <1> 
   125                              <1>     ; return registers
   126 00000796 59                  <1>     pop     cx
   127                              <1> 
   128                              <1>     ; destroy stack frame
   129 00000797 89EC                <1>     mov     sp, bp
   130 00000799 5D                  <1>     pop     bp
   131                              <1> 
   132 0000079A C3                  <1>     ret
   182                                  
   183                                  stage_4:
   184 0000079B 68[7008]E81FF983C4-         cdecl   puts, .s0               ; display a message
   184 000007A3 02                 
   185                                  
   186                                      ; enabling the A20 line
   187 000007A4 FA                          cli
   188 000007A5 68AD00E8D2FF83C402          cdecl   KBC_Cmd_Write, 0xAD     ; Disable first PS/2 port(keyboard)
   189                                  
   190 000007AE 68D000E8C9FF83C402          cdecl   KBC_Cmd_Write, 0xD0     ; Read Controller Output Port
   191 000007B7 68[B908]E89CFF83C4-         cdecl   KBC_Data_Read, .key
   191 000007BF 02                 
   192 000007C0 8A1E[B908]                  mov     bl, [.key]
   193 000007C4 80CB02                      or      bl, 0x02                ; enable A20 line
   194                                  
   195 000007C7 68D100E8B0FF83C402          cdecl   KBC_Cmd_Write, 0xD1     ; Write next byte to Controller Output Port
   196 000007D0 53E867FF83C402              cdecl   KBC_Data_Write, bx
   197                                  
   198 000007D7 68AE00E8A0FF83C402          cdecl   KBC_Cmd_Write, 0xAE     ; Enable first PS/2 port(keyboard)
   199 000007E0 FB                          sti
   200                                  
   201                                      ; print("A20 Gate Enabled.\n");
   202 000007E1 68[7F08]E8D9F883C4-         cdecl   puts, .s1
   202 000007E9 02                 
   203                                  
   204                                  
   205                                  
   206                                      ; keyboard led test
   207 000007EA 68[9408]E8D0F883C4-         cdecl   puts, .s2                                   ; print("Keyboard LED Test...")
   207 000007F2 02                 
   208 000007F3 BB0000                      mov     bx, 0
   209                                  .10L:                                                   ; do {
   210 000007F6 B400                        mov     ah, 0x00
   211 000007F8 CD16                        int     0x16                                        ;   AL = 1 character input
   212                                  
   213 000007FA 3C31                        cmp     al, '1'
   214 000007FC 7266                        jb      .10E
   215                                  
   216 000007FE 3C33                        cmp     al, '3'
   217 00000800 7762                        ja      .10E
   218                                  
   219 00000802 88C1                        mov     cl, al
   220 00000804 FEC9                        dec     cl
   221 00000806 80E103                      and     cl, 0x03                                    ;   cl = 0, 1 or 2
   222 00000809 B80100                      mov     ax, 0x0001
   223 0000080C D3E0                        shl     ax, cl
   224 0000080E 31C3                        xor     bx, ax                                      ;   set up a bit flag
   225                                  
   226                                      ; Set LEDs
   227 00000810 FA                          cli
   228 00000811 68AD00E866FF83C402          cdecl   KBC_Cmd_Write, 0xAD                         ;   Disable first PS/2 port(keyboard)
   229                                  
   230 0000081A 68ED00E81BFF83C402          cdecl   KBC_Data_Write, 0xED                        ;   LED command
   231 00000823 68[B908]E830FF83C4-         cdecl   KBC_Data_Read, .key
   231 0000082B 02                 
   232 0000082C 803E[B908]FA                cmp     [.key], byte 0xFA                           ;   if (key == ACK) {
   233 00000831 7509                        jne     .11F
   234 00000833 53E804FF83C402              cdecl   KBC_Data_Write, bx                          ;     set LEDs
   235 0000083A EB1C                        jmp     .11E                                        ;   }
   236                                  .11F:                                                   ;   else {
   237 0000083C 6A046A106A0268-             cdecl   itoa, word [.key], .e1, 2, 16, 0b0100       ;     print("[response byte]")
   237 00000843 [B508]FF36[B908]E8-
   237 0000084A D5F983C40A         
   238 0000084F 68[B408]E86BF883C4-         cdecl   puts, .e0
   238 00000857 02                 
   239                                  .11E:                                                   ;   }
   240 00000858 68AE00E81FFF83C402          cdecl   KBC_Cmd_Write, 0xAE                         ;   Enable first PS/2 port(keyboard)
   241 00000861 FB                          sti
   242 00000862 EB92                        jmp     .10L                                        ; } while(1);
   243                                  
   244                                  .10E:
   245                                  
   246 00000864 68[AA08]E856F883C4-         cdecl   puts, .s3   ; print("(done)")
   246 0000086C 02                 
   247                                  
   248                                      ; transition to the 5th stage
   249 0000086D E9BC00                      jmp     stage_5
   250                                  
   251 00000870 347468207374616765-     .s0:    db  "4th stage...", 0x0A, 0x0D, 0
   251 00000879 2E2E2E0A0D00       
   252 0000087F 204132302047617465-     .s1:    db  " A20 Gate Enabled.", 0x0A, 0x0D, 0
   252 00000888 20456E61626C65642E-
   252 00000891 0A0D00             
   253 00000894 204B6579626F617264-     .s2:    db  " Keyboard LED Test...", 0
   253 0000089D 204C45442054657374-
   253 000008A6 2E2E2E00           
   254 000008AA 2028646F6E65290A0D-     .s3:    db  " (done)", 0x0A, 0x0D, 0
   254 000008B3 00                 
   255 000008B4 5B                      .e0:    db  "["
   256 000008B5 5A5A5D00                .e1:    db  "ZZ]", 0
   257                                  
   258 000008B9 0000                    .key:   dw  0
   259                                  
   260                                  
   261                                      ; ----------------------------
   262                                      ; --- 5th stage of booting ---
   263                                      ; ----------------------------
   264                                  
   265                                      ; --- modules ---
   266                                      %include    "../modules/real/lba_chs.s"
     1                              <1> ; void lba_chs(struct drive *drive, struct drive *drv_chs, int16 lba);
     2                              <1> 
     3                              <1> ; return non-zero on success, and 0 on error
     4                              <1> ; drive : addr to drive params
     5                              <1> ; drv_chs : addr to CHS (struct drive) converted from LBA
     6                              <1> ; lba : this will be converted to CHS
     7                              <1> 
     8                              <1> 
     9                              <1> lba_chs:
    10                              <1> 
    11                              <1>     ; build stack frame
    12 000008BB 55                  <1>     push    bp
    13 000008BC 89E5                <1>     mov     bp, sp
    14                              <1> 
    15                              <1>     ; save registers
    16 000008BE 50                  <1>     push    ax
    17 000008BF 53                  <1>     push    bx
    18 000008C0 52                  <1>     push    dx
    19 000008C1 56                  <1>     push    si
    20 000008C2 57                  <1>     push    di
    21                              <1> 
    22                              <1> 
    23                              <1>     ; convert LBA to CHS
    24 000008C3 8B7604              <1>     mov     si, [bp + 4]        ; SI = *drive;
    25 000008C6 8B7E06              <1>     mov     di, [bp + 6]        ; DI = *drive_chs;
    26                              <1> 
    27                              <1>     ; calculate num of sectors per cylinder
    28 000008C9 8A4404              <1>     mov     al, [si + drive.head]
    29 000008CC F66406              <1>     mul     byte [si + drive.sect]  ; AX = num of heads * num of sects per track
    30 000008CF 89C3                <1>     mov     bx, ax
    31                              <1> 
    32                              <1>     ; calculate C
    33 000008D1 BA0000              <1>     mov     dx, 0
    34 000008D4 8B4608              <1>     mov     ax, [bp + 8]
    35 000008D7 F7F3                <1>     div     bx                      ; AX = DX:AX / BX, DX = DX:AX % BX;
    36 000008D9 894502              <1>     mov     [di + drive.cyln], ax
    37                              <1> 
    38                              <1>     ; calculate H and S
    39 000008DC 89D0                <1>     mov     ax, dx
    40 000008DE F67406              <1>     div     byte [si + drive.sect]  ; AH = AX % num of sects per track;
    41                              <1>                                     ; AL = AX / num of sects per track;
    42 000008E1 0FB6D4              <1>     movzx   dx, ah                  ; DX = S
    43 000008E4 B400                <1>     mov     ah, 0x00                ; AX = C
    44 000008E6 42                  <1>     inc     dx
    45                              <1> 
    46 000008E7 894504              <1>     mov     [di + drive.head], ax
    47 000008EA 895506              <1>     mov     [di + drive.sect], dx
    48                              <1> 
    49                              <1> 
    50                              <1>     ; return registers
    51 000008ED 5F                  <1>     pop     di
    52 000008EE 5E                  <1>     pop     si
    53 000008EF 5A                  <1>     pop     dx
    54 000008F0 5B                  <1>     pop     bx
    55 000008F1 58                  <1>     pop     ax
    56                              <1> 
    57                              <1>     ; destroy stack frame
    58 000008F2 89EC                <1>     mov     sp, bp
    59 000008F4 5D                  <1>     pop     bp
    60                              <1> 
    61 000008F5 C3                  <1>     ret
   267                                      %include    "../modules/real/read_lba.s"
     1                              <1> ; int16 read_lba(struct drice *drive, int16 lba, int 16 sect, int16 dst);
     2                              <1> 
     3                              <1> ; return number of sectors read
     4                              <1> ; drive: addr to drive struct of drive params
     5                              <1> ; sect: number of read sectors
     6                              <1> ; dst: dst addr
     7                              <1> 
     8                              <1> ; can't call this func before DS = 0, maybe
     9                              <1> 
    10                              <1> 
    11                              <1> read_lba:
    12                              <1> 
    13                              <1>     ; build stack frame
    14 000008F6 55                  <1>     push    bp
    15 000008F7 89E5                <1>     mov     bp, sp
    16                              <1> 
    17                              <1>     ; save registers
    18 000008F9 56                  <1>     push    si
    19                              <1> 
    20                              <1>     ; get drive params
    21 000008FA 8B7604              <1>     mov     si, [bp + 4]
    22                              <1> 
    23                              <1>     ; convert to CHS from LBA
    24 000008FD 8B4606              <1>     mov     ax, [bp + 6]
    25 00000900 5068[2409]56E8B3FF- <1>     cdecl   lba_chs, si, .chs, ax
    25 00000908 83C406              <1>
    26                              <1> 
    27                              <1>     ; copy drive number
    28 0000090B 8A04                <1>     mov     al, [si + drive.no]
    29 0000090D A2[2409]            <1>     mov     [.chs + drive.no], al
    30                              <1> 
    31                              <1>     ; read sectors
    32 00000910 FF760AFF760868-     <1>     cdecl   read_chs, .chs, word [bp + 8], word [bp + 10]
    32 00000917 [2409]E802F883C406  <1>
    33                              <1> 
    34                              <1> 
    35                              <1>     ; return registers
    36 0000091F 5E                  <1>     pop     si
    37                              <1> 
    38                              <1>     ; destroy stack frame
    39 00000920 89EC                <1>     mov     sp, bp
    40 00000922 5D                  <1>     pop     bp
    41                              <1> 
    42 00000923 C3                  <1>     ret
    43                              <1> 
    44                              <1> ALIGN 2
    45 00000924 00<rept>            <1> .chs:   times drive_size    db  0x00
   268                                  
   269                                  stage_5:
   270 0000092C 68[5809]E88EF783C4-         cdecl   puts, .s0               ; print("5th stage...");
   270 00000934 02                 
   271                                  
   272                                      ; load the kernel
   273 00000935 68009C6A106A1068-           cdecl   read_lba, BOOT, BOOT_SECT, KERNEL_SECT, BOOT_END
   273 0000093D [B800]E8B4FF83C408 
   274 00000945 83F810                      cmp     ax, KERNEL_SECT
   275 00000948 740C                        jz      .10E                    ; can't load kernel, then reboot
   276 0000094A 68[6709]E870F783C4-         cdecl   puts, .e0
   276 00000952 02                 
   277 00000953 E889F7                      call    reboot
   278                                  
   279                                  .10E:
   280                                      ; transition to the 6th stage
   281 00000956 EB29                        jmp     stage_6
   282                                  
   283 00000958 357468207374616765-     .s0:    db  "5th stage...", 0x0A, 0x0D, 0
   283 00000961 2E2E2E0A0D00       
   284 00000967 204661696C75726520-     .e0:    db  " Failure load kernel...", 0x0A, 0x0D, 0
   284 00000970 6C6F6164206B65726E-
   284 00000979 656C2E2E2E0A0D00   
   285                                  
   286                                  
   287                                      ; ----------------------------
   288                                      ; --- 6th stage of booting ---
   289                                      ; ----------------------------
   290                                  stage_6:
   291 00000981 68[9909]E839F783C4-         cdecl   puts, .s0               ; display a message
   291 00000989 02                 
   292                                  
   293                                      ; waiting for space key input
   294                                  .10L:
   295 0000098A B400                        mov     ah, 0x00                ; do {
   296 0000098C CD16                        int     0x16                    ;   al = 1 character input
   297 0000098E 3C20                        cmp     al, ' '                 ;   zf = (al == ' ')
   298 00000990 75F8                        jne     .10L                    ; } while (!zf)
   299                                  
   300                                      ; Set Video Mode
   301 00000992 B81200                      mov     ax, 0x12                ; VGA 640x480 16 color graphics 
   302 00000995 CD10                        int     0x10
   303                                  
   304                                      ; transition to the 7th stage
   305 00000997 EB5B                        jmp     stage_7
   306                                  
   307 00000999 367468207374616765-     .s0:    db  "6th stage...", 0x0A, 0x0D, 0x0A, 0x0D
   307 000009A2 2E2E2E0A0D0A0D     
   308 000009A9 205B50757368205350-             db  " [Push SPACE key to protect mode...]", 0x0A, 0x0D, 0
   308 000009B2 414345206B65792074-
   308 000009BB 6F2070726F74656374-
   308 000009C4 206D6F64652E2E2E5D-
   308 000009CD 0A0D00             
   309                                  
   310                                  
   311                                  
   312                                  
   313                                  
   314                                  
   315                                      ; ----------------------------
   316                                      ; Global segment Descriptor Table
   317                                      ; ----------------------------
   318                                  ALIGN 4, db 0
   319                                  ;          Base31:24_G_D_0_AVL_Limit19:16_P_DPL_DT_Type_base23:0_limit15:0
   320 000009D0 0000000000000000        GDT:    dq 0b00000000_0_0_0_0_0000_0_00_0_0000_000000000000000000000000_0000000000000000    ; NULL
   321 000009D8 FFFF0000009ACF00        .cosg:  dq 0b00000000_1_1_0_0_1111_1_00_1_1010_000000000000000000000000_1111111111111111    ; CODE 4G r/x
   322 000009E0 FFFF00000092CF00        .dasg:  dq 0b00000000_1_1_0_0_1111_1_00_1_0010_000000000000000000000000_1111111111111111    ; DATA 4G r/w
   323                                  .gdt_end:
   324                                  
   325                                      ; segment selectors (GDT)
   326                                  SEL_CODE    equ .cosg - GDT     ; Multiply the index by 8 because TI = 0 and RPL = 00
   327                                  SEL_DATA    equ .dasg - GDT     ; Multiply the index by 8 because TI = 0 and RPL = 00
   328                                  
   329                                  
   330                                      ; GDT base address and limit from memory into the GDTR register
   331                                  GDTR:
   332 000009E8 1700                        dw  GDT.gdt_end - GDT - 1   ; 16-Bit Table Limit
   333 000009EA [D0090000]                  dd  GDT                     ; 32-bit Linear Base Address
   334                                  
   335                                      ; IDT base address and limit from memory into the IDTR register
   336                                      ; Set empty IDT in order for the processor to ignore external interrupts 
   337                                  IDTR:
   338 000009EE 0000                        dw  0x00                    ; 16-Bit Table Limit
   339 000009F0 00000000                    dd  0x00                    ; 32-bit Linear Base Address
   340                                  
   341                                  
   342                                      ; ----------------------------
   343                                      ; --- 7th stage of booting ---
   344                                      ; ----------------------------
   345                                  
   346                                  stage_7:
   347 000009F4 FA                          cli
   348                                      ;  load and store the GDTR, IDTR
   349 000009F5 0F0116[E809]                lgdt    [GDTR]
   350 000009FA 0F011E[EE09]                lidt    [IDTR]
   351                                  
   352                                      ; Enable protected mode
   353 000009FF 0F20C0                      mov     eax, cr0
   354 00000A02 83C801                      or      ax, 1               ; CR0.PE |= 1
   355 00000A05 0F22C0                      mov     cr0, eax
   356                                  
   357                                      ; The JMP or CALL instruction immediately after the MOV CR0 instruction changes the flow of execution and serializes the processor
   358 00000A08 EB00                        jmp     $ + 2
   359                                  
   360                                  [BITS 32]
   361 00000A0A 66                          db  0x66    ; The instruction prefix 66H can be used to select an operand size other than the default
   362 00000A0B EA[120A0000]0800            jmp     SEL_CODE:CODE32
   363                                  
   364                                  
   365                                      ; --- 32bit code segment ---
   366                                  CODE32:
   367                                      ; Initialize selectors (cs has already been Initialized)
   368 00000A12 66B81000                    mov     ax, SEL_DATA
   369 00000A16 8ED8                        mov     ds, ax
   370 00000A18 8EC0                        mov     es, ax
   371 00000A1A 8EE0                        mov     fs, ax
   372 00000A1C 8EE8                        mov     gs, ax
   373 00000A1E 8ED0                        mov     ss, ax
   374                                  
   375                                      ; copy kernel to 0x0010_1000 4bytes at a time
   376 00000A20 B900080000                  mov     ecx, (KERNEL_SIZE) / 4
   377 00000A25 BE009C0000                  mov     esi, BOOT_END           ; kernel is set at BOOT_END (= 0x9c00) in the process of 6th stage
   378 00000A2A BF00101000                  mov     edi, KERNEL_LOAD        ; EDI = 0x0010_1000
   379 00000A2F FC                          cld
   380 00000A30 F3A5                        rep     movsd
   381                                  
   382                                  
   383                                      ; --- jump into the kernel ---
   384 00000A32 E9(00101000)                jmp     KERNEL_LOAD
   385                                  
   386                                  
   387                                  ; --- padding ---
   388 00000A37 00<rept>                times BOOT_SIZE - ($- $$)  db  0   ; up to 8K
