     1                                      ; --- macro ---
     2                                      %include    "../include/define.s"
     1                              <1> ; defines of important constants
     2                              <1> 
     3                              <1> SECT_SIZE   equ     (512)                       ; size of a sector
     4                              <1> 
     5                              <1> 
     6                              <1> BOOT_LOAD   equ     0x7c00                      ; addr where boot program loaded
     7                              <1> BOOT_SIZE   equ     (1024 * 8)                  ; size of boot code
     8                              <1> BOOT_SECT   equ     (BOOT_SIZE / SECT_SIZE)     ; number of sectors used in boot program
     9                              <1> BOOT_END    equ     (BOOT_LOAD + BOOT_SIZE)     ; the end of boot code
    10                              <1> 
    11                              <1> E820_RECORD_SIZE    equ     20                  ; the record size (size of buffer for result) used in INT 0x15, EAX = 0xE820
    12                              <1> 
    13                              <1> 
    14                              <1> KERNEL_LOAD equ     0x0010_1000                 ; addr where the kernel loaded
    15                              <1> KERNEL_SIZE equ     (1024 * 8)                  ; size of the kernel
    16                              <1> KERNEL_SECT equ     (KERNEL_SIZE / SECT_SIZE)   ; number of sectors used in kernel
     3                                      %include    "../include/macro.s"
     1                              <1> ; --- cdecl ---
     2                              <1> 
     3                              <1> %macro cdecl 1-*.nolist
     4                              <1>     %rep    %0 - 1
     5                              <1>         push    %{-1:-1}
     6                              <1>         %rotate -1
     7                              <1>     %endrep
     8                              <1>     %rotate -1
     9                              <1> 
    10                              <1>     call    %1
    11                              <1> 
    12                              <1>     %if 1 < %0          ; delete args
    13                              <1>         add     sp, (__BITS__ >> 3) * (%0 - 1)      ; if realmode then __BITS__ = 16
    14                              <1>     %endif
    15                              <1> %endmacro
    16                              <1> 
    17                              <1> 
    18                              <1> ; --- drive struct ---
    19                              <1> struc drive
    20 00000000 <res 00000002>      <1>     .no     resw    1       ; drive number
    21 00000002 <res 00000002>      <1>     .cyln   resw    1       ; cylinder
    22 00000004 <res 00000002>      <1>     .head   resw    1       ; head
    23 00000006 <res 00000002>      <1>     .sect   resw    1       ; sector
    24                              <1> endstruc
     4                                  
     5                                      ORG     BOOT_LOAD
     6                                  
     7                                      ; --- entry point ---
     8                                  entry: 
     9 00000000 EB58                        jmp     ipl
    10                                  
    11                                  
    12                                      ; --- BIOS Parameter Block ---
    13 00000002 90<rept>                    times   90 - ($ - $$) db 0x90
    14                                  
    15                                  
    16                                      ; --- Initial Program Loader ---
    17                                  ipl:
    18                                  
    19 0000005A FA                          cli
    20                                  
    21 0000005B B80000                      mov     ax, 0x00
    22 0000005E 8ED8                        mov     ds, ax
    23 00000060 8EC0                        mov     es, ax
    24 00000062 8ED0                        mov     ss, ax                      ; ds = es = ss = 0
    25 00000064 BC007C                      mov     sp, BOOT_LOAD               ; sp = 0x7c00
    26                                  
    27 00000067 FB                          sti
    28                                  
    29 00000068 8816[B800]                  mov     [BOOT + drive.no],    dl    ; save drive number
    30                                  
    31 0000006C 68[9900]E84E0083C4-         cdecl   puts, .s0                   ; write text in teletype mode
    31 00000074 02                 
    32                                  
    33                                  
    34                                      ; read all the sectors left
    35 00000075 BB0F00                      mov     bx, BOOT_SECT - 1               ; bx = number of sectors left
    36 00000078 B9007E                      mov     cx, BOOT_LOAD + SECT_SIZE       ; cx = addr where next sectors will be loaded
    37 0000007B 515368[B800]E89B00-         cdecl   read_chs, BOOT, bx, cx          ; ax = read_chs(BOOT, bx, cx);
    37 00000083 83C406             
    38                                  
    39 00000086 39D8                        cmp     ax, bx
    40 00000088 740C                        jz      .10E                    ; if success, jump to .10E
    41                                  
    42 0000008A 68[A600]E8300083C4-         cdecl   puts, .e0
    42 00000092 02                 
    43 00000093 E84900                      call    reboot
    44                                  .10E:
    45                                  
    46                                      ; transition to the 2nd stage
    47 00000096 E96902                      jmp     stage_2
    48                                  
    49                                  
    50                                  
    51 00000099 426F6F74696E672E2E-     .s0:    db  "Booting...", 0x0A, 0x0D, 0x00
    51 000000A2 2E0A0D00           
    52 000000A6 4572726F723A736563-     .e0:    db  "Error:sector read", 0x00
    52 000000AF 746F72207265616400 
    53                                  
    54                                      ALIGN 2, db 0
    55                                  BOOT:
    56                                      istruc  drive
    57 000000B8 0000                            at  drive.no,   dw  0   ; drive number
    58 000000BA 0000                            at  drive.cyln, dw  0   ; cylinder
    59 000000BC 0000                            at  drive.head, dw  0   ; head
    60 000000BE 0200                            at  drive.sect, dw  2   ; sector
    61                                      iend
    62                                  
    63                                      ; --- modules ---
    64                                      %include    "../modules/real/puts.s"
     1                              <1> ; void puts(int16 straddr)
     2                              <1> ; write str from head to '\0'
     3                              <1> 
     4                              <1> 
     5                              <1> puts:
     6                              <1> 
     7                              <1>     ; build stack frame
     8 000000C0 55                  <1>     push    bp
     9 000000C1 89E5                <1>     mov     bp, sp
    10                              <1> 
    11                              <1>     ; save registers
    12 000000C3 50                  <1>     push    ax
    13 000000C4 53                  <1>     push    bx
    14 000000C5 56                  <1>     push    si
    15                              <1> 
    16                              <1>     ; get arg
    17 000000C6 8B7604              <1>     mov     si, [bp + 4]    ; si = straddr
    18                              <1> 
    19                              <1>     ; write text in teletype mode
    20 000000C9 B40E                <1>     mov     ah, 0x0E
    21 000000CB BB0000              <1>     mov     bx, 0x00
    22 000000CE FC                  <1>     cld                     ; DF = 0    
    23                              <1> .10L:
    24 000000CF AC                  <1>     lodsb
    25 000000D0 3C00                <1>     cmp     al, 0           ; if (*(si++) == 0)
    26 000000D2 7404                <1>     je      .10E            ; break;
    27 000000D4 CD10                <1>     int     0x10
    28 000000D6 EBF7                <1>     jmp     .10L
    29                              <1> .10E:
    30                              <1> 
    31                              <1>     ; return registers
    32 000000D8 5E                  <1>     pop     si
    33 000000D9 5B                  <1>     pop     bx
    34 000000DA 58                  <1>     pop     ax
    35                              <1> 
    36                              <1>     ; destroy stack frame
    37 000000DB 89EC                <1>     mov     sp, bp
    38 000000DD 5D                  <1>     pop     bp
    39                              <1> 
    40 000000DE C3                  <1>     ret
    65                                      %include    "../modules/real/reboot.s"
     1                              <1> ; reboot
     2                              <1> 
     3                              <1> 
     4                              <1> reboot:
     5                              <1>     ; display a message
     6 000000DF 68[FB00]E8DBFF83C4- <1>     cdecl   puts, .s0
     6 000000E7 02                  <1>
     7                              <1> 
     8                              <1>     ; wait for key-input
     9                              <1> .10L:
    10 000000E8 B410                <1>     mov     ah, 0x10
    11 000000EA CD16                <1>     int     0x16            ; get key-input
    12                              <1> 
    13 000000EC 3C20                <1>     cmp     al, ' '
    14 000000EE 75F8                <1>     jne     .10L
    15                              <1> 
    16                              <1>     ; output newline
    17 000000F0 68[1901]E8CAFF83C4- <1>     cdecl   puts, .s1
    17 000000F8 02                  <1>
    18                              <1> 
    19                              <1>     ; reboot
    20 000000F9 CD19                <1>     int     0x19
    21                              <1> 
    22                              <1> 
    23 000000FB 0A0D50757368205350- <1> .s0:    db  0x0A, 0x0D, "Push SPACE key to reboot...", 0
    23 00000104 414345206B65792074- <1>
    23 0000010D 6F207265626F6F742E- <1>
    23 00000116 2E2E00              <1>
    24 00000119 0A0D0A0D00          <1> .s1:    db  0x0A, 0x0D, 0x0A, 0x0D, 0
    66                                      %include    "../modules/real/read_chs.s"
     1                              <1> ; int read_chs(int drive, int sect, int dst)
     2                              <1> ; return number of sectors read
     3                              <1> ; drive: addr to drive struct
     4                              <1> ; sect: number of read sectors
     5                              <1> ; dst: dst addr
     6                              <1> 
     7                              <1> ; can't call this func before DS = 0, maybe
     8                              <1> 
     9                              <1> 
    10                              <1> read_chs:
    11                              <1> 
    12                              <1>     ; build stack frame
    13 0000011E 55                  <1>     push    bp
    14 0000011F 89E5                <1>     mov     bp, sp
    15 00000121 6A03                <1>     push    3           ; number of retries
    16 00000123 6A00                <1>     push    0           ; number of sectors read
    17                              <1> 
    18                              <1>     ; save registers
    19 00000125 53                  <1>     push    bx
    20 00000126 51                  <1>     push    cx
    21 00000127 52                  <1>     push    dx
    22 00000128 06                  <1>     push    es
    23 00000129 56                  <1>     push    si
    24                              <1> 
    25                              <1>     ; set cx, dx, es, bx for reading sectors (CHS)
    26 0000012A 8B7604              <1>     mov     si, [bp + 4]                ; si = addr to drive struct
    27 0000012D 8A6C02              <1>     mov     ch, [si + drive.cyln] 
    28 00000130 8A4C03              <1>     mov     cl, [si + drive.cyln + 1]
    29 00000133 C0E106              <1>     shl     cl, 6
    30 00000136 0A4C06              <1>     or      cl, [si + drive.sect]
    31                              <1> 
    32 00000139 8A7404              <1>     mov     dh, [si + drive.head]
    33 0000013C 8A14                <1>     mov     dl, [si + 0]
    34                              <1> 
    35 0000013E B80000              <1>     mov     ax, 0
    36 00000141 8EC0                <1>     mov     es, ax
    37 00000143 8B5E08              <1>     mov     bx, [bp + 8]
    38                              <1> 
    39                              <1> .10L:
    40                              <1>     ; read sectors
    41 00000146 B402                <1>     mov     ah, 0x02
    42 00000148 8A4606              <1>     mov     al, [bp + 6]
    43                              <1> 
    44 0000014B CD13                <1>     int     0x13
    45 0000014D 7304                <1>     jnc      .11E        ; if error occured, jump to .11E
    46 0000014F B000                <1>     mov     al, 0
    47 00000151 EB0C                <1>     jmp     .10E
    48                              <1> 
    49                              <1> .11E:
    50 00000153 3C00                <1>     cmp     al, 0
    51 00000155 7508                <1>     jne     .10E        ; if at least one sector was read
    52                              <1> 
    53 00000157 B80000              <1>     mov     ax, 0
    54 0000015A FF4EFE              <1>     dec     word    [bp - 2]    ; retry--
    55 0000015D 75E7                <1>     jnz     .10L                ; read sectors again
    56                              <1> 
    57                              <1> .10E:
    58                              <1>     ; remove status info
    59 0000015F B400                <1>     mov     ah, 0
    60                              <1> 
    61                              <1>     ; return registers
    62 00000161 5E                  <1>     pop     si
    63 00000162 07                  <1>     pop     es
    64 00000163 5A                  <1>     pop     dx
    65 00000164 59                  <1>     pop     cx
    66 00000165 5B                  <1>     pop     bx
    67                              <1> 
    68                              <1>     ; destroy stack frame
    69 00000166 89EC                <1>     mov     sp, bp
    70 00000168 5D                  <1>     pop     bp
    71                              <1> 
    72 00000169 C3                  <1>     ret
    67                                  
    68                                  
    69                                      ; --- boot flag ---
    70 0000016A 00<rept>                    times   510 - ($ - $$) db 0x00
    71 000001FE 55AA                        db      0x55, 0xAA              ; boot flag
    72                                  
    73                                  
    74                                      ; ----------------------------
    75                                      ; informations obtained in real mode
    76                                      ; ----------------------------
    77                                  
    78                                      ; BIOS font data addr
    79                                  FONT:
    80 00000200 0000                    .seg    dw  0
    81 00000202 0000                    .off    dw  0
    82                                      ; ACPI data address 
    83                                  ACPI_DATA:
    84 00000204 00000000                .adr:   dd  0
    85 00000208 00000000                .len:   dd  0
    86                                  
    87                                      ; ----------------------------
    88                                      ; --- 2nd stage of booting ---
    89                                      ; ----------------------------
    90                                  
    91                                      ; --- modules ---
    92                                      %include    "../modules/real/putc.s"
     1                              <1> ; void putc(int16 chcode)
     2                              <1> 
     3                              <1> putc:
     4                              <1> 
     5                              <1>     ; build stack frame
     6 0000020C 55                  <1>     push    bp
     7 0000020D 89E5                <1>     mov     bp, sp
     8                              <1> 
     9                              <1>     ; save registers
    10 0000020F 50                  <1>     push    ax
    11 00000210 53                  <1>     push    bx
    12                              <1> 
    13                              <1> 
    14                              <1>     ; write text in teletype mode
    15 00000211 8A4604              <1>     mov     al, [bp + 4]
    16 00000214 B40E                <1>     mov     ah, 0x0E
    17 00000216 BB0000              <1>     mov     bx, 0x00
    18 00000219 CD10                <1>     int     0x10
    19                              <1> 
    20                              <1> 
    21                              <1>     ; return registers
    22 0000021B 5B                  <1>     pop     bx
    23 0000021C 58                  <1>     pop     ax
    24                              <1> 
    25                              <1>     ; destroy stack frame
    26 0000021D 89EC                <1>     mov     sp, bp
    27 0000021F 5D                  <1>     pop     bp
    28                              <1> 
    29 00000220 C3                  <1>     ret
    93                                      %include    "../modules/real/itoa.s"
     1                              <1> ; void itos(int num, char* buf, int size, int radix, int flags);
     2                              <1> ; flags = 1 : num is used as signed
     3                              <1> ; flags = 2 : display plus/minus sign
     4                              <1> ; flags = 4 : fill in the space with 0
     5                              <1> 
     6                              <1> 
     7                              <1> itoa:
     8                              <1>     ; build stack frame
     9 00000221 55                  <1>     push    bp
    10 00000222 89E5                <1>     mov     bp, sp
    11                              <1> 
    12                              <1>     ; save registers' data
    13 00000224 50                  <1>     push    ax
    14 00000225 53                  <1>     push    bx
    15 00000226 51                  <1>     push    cx
    16 00000227 52                  <1>     push    dx
    17 00000228 56                  <1>     push    si
    18 00000229 57                  <1>     push    di
    19                              <1> 
    20                              <1>     ; get args
    21 0000022A 8B4604              <1>     mov     ax, [bp + 4]    ; ax = num;
    22 0000022D 8B7606              <1>     mov     si, [bp + 6]    ; si = buf;
    23 00000230 8B4E08              <1>     mov     cx, [bp + 8]    ; cx = size;
    24                              <1> 
    25 00000233 89F7                <1>     mov     di, si
    26 00000235 01CF                <1>     add     di, cx
    27 00000237 4F                  <1>     dec     di              ; di = &(buf[size - 1]);
    28                              <1> 
    29 00000238 8B5E0C              <1>     mov     bx, [bp + 12]   ; bx = flags;
    30                              <1> 
    31                              <1>     ; positive/negative judgement
    32 0000023B F7C30100            <1>     test    bx, 0b0001      ; if (flags & 0x01)
    33 0000023F 7408                <1>     je      .10E
    34 00000241 83F800              <1>     cmp     ax, 0           ;   if (num < 0)
    35 00000244 7D03                <1>     jge     .12E
    36 00000246 83CB02              <1>     or      bx, 0b0010      ;       flags |= 2;
    37                              <1> .10E:
    38                              <1> .12E:
    39                              <1> 
    40                              <1>     ; which sould be displayed pos/neg ?
    41 00000249 F7C30200            <1>     test    bx, 0b0010
    42 0000024D 7410                <1>     je      .20E
    43 0000024F 83F800              <1>     cmp     ax, 0
    44 00000252 7D07                <1>     jge     .22F
    45 00000254 F7D8                <1>     neg     ax              ; num *= -1;
    46 00000256 C6042D              <1>     mov     [si], byte '-'  ; buf[0] = '-';
    47 00000259 EB03                <1>     jmp     .22E
    48                              <1> .22F:
    49 0000025B C6042B              <1>     mov     [si], byte '+'
    50                              <1> .22E:
    51 0000025E 49                  <1>     dec     cx
    52                              <1> .20E:
    53                              <1> 
    54                              <1> 
    55                              <1>     ; convert num to ASCII
    56 0000025F 8B5E0A              <1>     mov     bx, [bp + 10]           ; bx = radix
    57                              <1> .30L:
    58 00000262 BA0000              <1>     mov     dx, 0
    59 00000265 F7F3                <1>     div     bx                      ; ax = dx:ax % bx,;     dx = dx:ax % bx;
    60                              <1> 
    61 00000267 89D6                <1>     mov     si, dx
    62 00000269 8A94[9202]          <1>     mov     dl, byte [.ascii + si]  ; dl = ascii[si];
    63                              <1> 
    64 0000026D 8815                <1>     mov     [di], dl                ; buf[size - i]
    65 0000026F 4F                  <1>     dec     di
    66                              <1> 
    67 00000270 83F800              <1>     cmp     ax, 0
    68 00000273 E0ED                <1>     loopnz  .30L
    69                              <1> 
    70                              <1> 
    71                              <1>     ; fill in the space
    72 00000275 83F900              <1>     cmp     cx, 0
    73 00000278 740E                <1>     je      .40E
    74 0000027A B020                <1>     mov     al, ' '
    75 0000027C F7460C0400          <1>     test    [bp + 12], word 0b0100  ; if (flags & 0x04)
    76 00000281 7402                <1>     je     .42E
    77 00000283 B030                <1>     mov     al, '0'
    78                              <1> .42E:
    79 00000285 FD                  <1>     std                             ; DF = 1 (- direction)
    80 00000286 F3AA                <1>     rep stosb                       ; while(--cx) [di--] = al;
    81                              <1> .40E:
    82                              <1> 
    83                              <1> 
    84                              <1>     ; return registers' data
    85 00000288 5F                  <1>     pop     di
    86 00000289 5E                  <1>     pop     si
    87 0000028A 5A                  <1>     pop     dx
    88 0000028B 59                  <1>     pop     cx
    89 0000028C 5B                  <1>     pop     bx
    90 0000028D 58                  <1>     pop     ax
    91                              <1> 
    92                              <1>     ; destroy stack frame
    93 0000028E 89EC                <1>     mov     sp, bp
    94 00000290 5D                  <1>     pop     bp
    95                              <1> 
    96 00000291 C3                  <1>     ret
    97                              <1> 
    98                              <1> 
    99 00000292 303132333435363738- <1> .ascii: db  "0123456789ABCDEF"      ; ascii-short table
    99 0000029B 39414243444546      <1>
   100                              <1> 
    94                                      %include    "../modules/real/get_drive_params.s"
     1                              <1> ; int get_drive_param(int drive)
     2                              <1> 
     3                              <1> ; set maximam accessible number of sectors, cylinders and heads coressponding drive number
     4                              <1> 
     5                              <1> ; drive: addr to drive struct
     6                              <1> ; return non-zero on success, and 0 on error 
     7                              <1> 
     8                              <1> 
     9                              <1> get_drive_params:
    10                              <1> 
    11                              <1>     ; build stack frame
    12 000002A2 55                  <1>     push    bp
    13 000002A3 89E5                <1>     mov     bp, sp
    14                              <1> 
    15                              <1>     ; save registers
    16 000002A5 53                  <1>     push    bx
    17 000002A6 51                  <1>     push    cx
    18 000002A7 06                  <1>     push    es
    19 000002A8 56                  <1>     push    si
    20 000002A9 57                  <1>     push    di
    21                              <1> 
    22                              <1>     
    23 000002AA 8B7604              <1>     mov     si, [bp + 4]                ; si = addr to drive struct
    24                              <1> 
    25                              <1>     ; initialize Disk Base Table pointer
    26 000002AD B80000              <1>     mov     ax, 0
    27 000002B0 8EC0                <1>     mov     es, ax
    28 000002B2 89C7                <1>     mov     di, ax
    29                              <1> 
    30                              <1>     ; get current drive parameters
    31 000002B4 B408                <1>     mov     ah, 8
    32 000002B6 8A14                <1>     mov     dl, [si + drive.no]
    33 000002B8 CD13                <1>     int     0x13
    34 000002BA 721A                <1>     jc      .10F
    35                              <1>     ; success
    36 000002BC 88C8                <1>     mov     al, cl
    37 000002BE 243F                <1>     and     al, 0x3F        ; ax = number of sectors
    38                              <1> 
    39 000002C0 C0E906              <1>     shr     cl, 6
    40 000002C3 C1C908              <1>     ror     cx, 8
    41 000002C6 41                  <1>     inc     cx              ; cx = number of cylinders
    42                              <1> 
    43 000002C7 0FB6DE              <1>     movzx   bx, dh
    44 000002CA 43                  <1>     inc     bx              ; bx = number of heads
    45                              <1> 
    46 000002CB 894406              <1>     mov     [si + drive.sect], ax
    47 000002CE 894C02              <1>     mov     [si + drive.cyln], cx
    48 000002D1 895C04              <1>     mov     [si + drive.head], bx
    49                              <1> 
    50 000002D4 EB03                <1>     jmp     .10E
    51                              <1>     ; error
    52                              <1> .10F:
    53 000002D6 B80000              <1>     mov     ax, 0
    54                              <1> 
    55                              <1> 
    56                              <1> .10E:
    57                              <1>     ; return registers
    58 000002D9 5F                  <1>     pop     di
    59 000002DA 5E                  <1>     pop     si
    60 000002DB 07                  <1>     pop     es
    61 000002DC 59                  <1>     pop     cx
    62 000002DD 5B                  <1>     pop     bx
    63                              <1> 
    64                              <1>     ; destroy stack frame
    65 000002DE 89EC                <1>     mov     sp, bp
    66 000002E0 5D                  <1>     pop     bp
    67                              <1> 
    68 000002E1 C3                  <1>     ret
    95                                      %include    "../modules/real/get_font_adr.s"
     1                              <1> ; void get_font_adr(long adr);
     2                              <1> ; adr = addr to BIOS font data
     3                              <1> 
     4                              <1> get_font_data:
     5                              <1> 
     6                              <1>     ; build stack frame
     7 000002E2 55                  <1>     push    bp
     8 000002E3 89E5                <1>     mov     bp, sp
     9                              <1> 
    10                              <1>     ; save registers
    11 000002E5 50                  <1>     push    ax
    12 000002E6 53                  <1>     push    bx
    13 000002E7 56                  <1>     push    si
    14 000002E8 06                  <1>     push    es
    15 000002E9 55                  <1>     push    bp
    16                              <1> 
    17                              <1>     ; get the arg
    18 000002EA 8B7604              <1>     mov     si, [bp + 4]
    19                              <1>     
    20                              <1>     ; get BIOS font addr
    21 000002ED B83011              <1>     mov     ax, 0x1130      ; get current character generator information
    22 000002F0 B706                <1>     mov     bh, 0x06        ; 8x16 character
    23 000002F2 CD10                <1>     int     10h             ; ES:BP = font addr
    24                              <1> 
    25                              <1>     ; save font address
    26 000002F4 8C04                <1>     mov     [si + 0], es    ; segment
    27 000002F6 896C02              <1>     mov     [si + 2], bp    ; offset
    28                              <1> 
    29                              <1>     ; return registers
    30 000002F9 5D                  <1>     pop     bp
    31 000002FA 07                  <1>     pop     es
    32 000002FB 5E                  <1>     pop     si
    33 000002FC 5B                  <1>     pop     bx
    34 000002FD 58                  <1>     pop     ax
    35                              <1> 
    36                              <1>     ; destroy stack frame
    37 000002FE 89EC                <1>     mov     sp, bp
    38 00000300 5D                  <1>     pop     bp
    39                              <1> 
    40 00000301 C3                  <1>     ret
    96                                  
    97                                  stage_2:
    98 00000302 68[7D03]E8B8FD83C4-         cdecl   puts, .s0               ; display a message
    98 0000030A 02                 
    99                                  
   100                                      ; get drive params
   101 0000030B 68[B800]E891FF83C4-         cdecl   get_drive_params, BOOT
   101 00000313 02                 
   102 00000314 83F800                      cmp     ax, 0
   103 00000317 750C                        jne     .10E
   104 00000319 68[B403]E8A1FD83C4-         cdecl   puts, .e0               ; display an error message
   104 00000321 02                 
   105 00000322 E8BAFD                      call    reboot
   106                                  .10E:
   107                                      ; display information of drive params
   108 00000325 A1[B800]                    mov     ax, [BOOT + drive.no]
   109 00000328 6A046A106A0268-             cdecl   itoa, ax, .p1, 2, 16, 0b0100
   109 0000032F [9503]50E8ECFE83C4-
   109 00000337 0A                 
   110 00000338 A1[BA00]                    mov     ax, [BOOT + drive.cyln]
   111 0000033B 6A046A106A0468-             cdecl   itoa, ax, .p2, 4, 16, 0b0100
   111 00000342 [9D03]50E8D9FE83C4-
   111 0000034A 0A                 
   112 0000034B A1[BC00]                    mov     ax, [BOOT + drive.head]
   113 0000034E 6A046A106A0268-             cdecl   itoa, ax, .p3, 2, 16, 0b0100
   113 00000355 [A703]50E8C6FE83C4-
   113 0000035D 0A                 
   114 0000035E A1[BE00]                    mov     ax, [BOOT + drive.sect]
   115 00000361 6A046A106A0268-             cdecl   itoa, ax, .p4, 2, 16, 0b0100
   115 00000368 [AF03]50E8B3FE83C4-
   115 00000370 0A                 
   116 00000371 68[8C03]E849FD83C4-         cdecl   puts, .s1                       ; puts(.s1 ~ .p4)
   116 00000379 02                 
   117                                  
   118                                      ; transition to the 3rd stage
   119 0000037A E9FF02                      jmp     stage_3rd
   120                                  
   121 0000037D 326E64207374616765-     .s0:    db  "2nd stage...", 0x0A, 0x0D, 0
   121 00000386 2E2E2E0A0D00       
   122                                  
   123 0000038C 2044726976653A3078      .s1:    db  " Drive:0x"
   124 00000395 20202C20433A3078        .p1:    db  "  , C:0x"
   125 0000039D 202020202C20483A30-     .p2:    db  "    , H:0x"
   125 000003A6 78                 
   126 000003A7 20202C20533A3078        .p3:    db  "  , S:0x"
   127 000003AF 20200A0D00              .p4:    db  "  ", 0x0A, 0x0D, 0
   128                                  
   129 000003B4 43616E277420676574-     .e0:    db  "Can't get drive parameter.", 0
   129 000003BD 206472697665207061-
   129 000003C6 72616D657465722E00 
   130                                  
   131                                  
   132                                      ; ----------------------------
   133                                      ; --- 3rd stage of booting ---
   134                                      ; ----------------------------
   135                                  
   136                                      ; --- modules ---
   137                                      %include    "../modules/real/get_mem_info.s"
     1                              <1> ; void get_mem_info(void)
     2                              <1> ; get mem info using INT 0x15, EAX = 0xE820, and store ACPI info in ACPI_DATA in the global area
     3                              <1> 
     4                              <1> 
     5                              <1> get_mem_info:
     6                              <1> 
     7                              <1>     ; save registers
     8 000003CF 6650                <1>     push    eax
     9 000003D1 6653                <1>     push    ebx
    10 000003D3 6651                <1>     push    ecx
    11 000003D5 6652                <1>     push    edx
    12 000003D7 56                  <1>     push    si
    13 000003D8 57                  <1>     push    di
    14 000003D9 55                  <1>     push    bp
    15                              <1> 
    16 000003DA 68[6E04]E8E0FC83C4- <1>     cdecl   puts, .s0
    16 000003E2 02                  <1>
    17 000003E3 BD0000              <1>     mov     bp, 0                       ; line = 0;
    18 000003E6 66BB00000000        <1>     mov     ebx, 0                      ; continuation value or zero to start at beginning of map
    19                              <1> .10L:                                                                                   ; do {
    20 000003EC 66B820E80000        <1>     mov     eax, 0xE820
    21 000003F2 66B914000000        <1>     mov     ecx, E820_RECORD_SIZE       ; size of buffer for result, in bytes
    22 000003F8 66BA50414D53        <1>     mov     edx, 'PAMS'                 ; edx = 'SMAP'
    23 000003FE BF[F804]            <1>     mov     di, .b0                     ; ES:DI -> buffer for result
    24 00000401 CD15                <1>     int     0x15                        ; Newer BIOSes - GET SYSTEM MEMORY MAP
    25                              <1> 
    26                              <1>     ; Is the BIOS support this interrupt service?
    27 00000403 663D50414D53        <1>     cmp     eax, 'PAMS'
    28 00000409 7402                <1>     je      .12E
    29 0000040B EB4C                <1>     jmp     .10E
    30                              <1> .12E:
    31                              <1>     ; error check
    32 0000040D 7302                <1>     jnc     .14E
    33 0000040F EB48                <1>     jmp     .10E
    34                              <1> 
    35                              <1> .14E:
    36 00000411 57E8F70083C402      <1>     cdecl   put_mem_info, di            ; display mem info of one record
    37                              <1> 
    38                              <1>     ; get addrs of ACPI data 
    39 00000418 668B4510            <1>     mov     eax, [di + 16]              ; eax = data type
    40 0000041C 6683F803            <1>     cmp     eax, 3                      ; Is data type ACPI Reclaim Memory?
    41 00000420 750F                <1>     jne     .15E
    42                              <1> 
    43 00000422 668B05              <1>     mov     eax, [di + 0]
    44 00000425 66A3[0402]          <1>     mov     [ACPI_DATA.adr], eax        ; base addr
    45                              <1> 
    46 00000429 668B4508            <1>     mov     eax, [di + 8]
    47 0000042D 66A3[0802]          <1>     mov     [ACPI_DATA.len], eax        ; length
    48                              <1> 
    49                              <1> .15E:
    50                              <1>     ; display a message per 8 lines to prevent the screen from being refleshed
    51 00000431 6683FB00            <1>     cmp     ebx, 0                      ; all done?
    52 00000435 741C                <1>     jz      .16E
    53                              <1> 
    54 00000437 45                  <1>     inc     bp                          ; line++;
    55 00000438 83E507              <1>     and     bp, 0x07
    56 0000043B 7516                <1>     jnz     .16E
    57                              <1>     ; display a message
    58 0000043D 68[E104]E87DFC83C4- <1>     cdecl   puts, .s2
    58 00000445 02                  <1>
    59                              <1> 
    60 00000446 B410                <1>     mov     ah, 0x10
    61 00000448 CD16                <1>     int     0x16                        ; waiting for key-in
    62                              <1> 
    63 0000044A 68[EC04]E870FC83C4- <1>     cdecl   puts, .s3                   ; remove the message 
    63 00000452 02                  <1>
    64                              <1> 
    65                              <1> .16E:
    66 00000453 6683FB00            <1>     cmp     ebx, 0
    67 00000457 7593                <1>     jne     .10L                                                                                ; } while(0 != ebx)
    68                              <1> 
    69                              <1> 
    70                              <1> .10E:
    71 00000459 68[B104]E861FC83C4- <1>     cdecl   puts, .s1
    71 00000461 02                  <1>
    72                              <1> 
    73                              <1>     ; return registers
    74 00000462 5D                  <1>     pop     bp
    75 00000463 5F                  <1>     pop     di
    76 00000464 5E                  <1>     pop     si
    77 00000465 665A                <1>     pop     edx
    78 00000467 6659                <1>     pop     ecx
    79 00000469 665B                <1>     pop     ebx
    80 0000046B 6658                <1>     pop     eax
    81                              <1> 
    82                              <1> 
    83 0000046D C3                  <1>     ret
    84                              <1> 
    85                              <1> 
    86 0000046E 2045383230204D656D- <1> .s0:	db " E820 Memory Map:", 0x0A, 0x0D
    86 00000477 6F7279204D61703A0A- <1>
    86 00000480 0D                  <1>
    87 00000481 20426173655F5F5F5F- <1> 		db " Base_____________ Length___________ Type____", 0x0A, 0x0D, 0
    87 0000048A 5F5F5F5F5F5F5F5F5F- <1>
    87 00000493 204C656E6774685F5F- <1>
    87 0000049C 5F5F5F5F5F5F5F5F5F- <1>
    87 000004A5 20547970655F5F5F5F- <1>
    87 000004AE 0A0D00              <1>
    88 000004B1 202D2D2D2D2D2D2D2D- <1> .s1:	db " ----------------- ----------------- --------", 0x0A, 0x0D, 0
    88 000004BA 2D2D2D2D2D2D2D2D2D- <1>
    88 000004C3 202D2D2D2D2D2D2D2D- <1>
    88 000004CC 2D2D2D2D2D2D2D2D2D- <1>
    88 000004D5 202D2D2D2D2D2D2D2D- <1>
    88 000004DE 0A0D00              <1>
    89 000004E1 203C6D6F72652E2E2E- <1> .s2:    db  " <more...>", 0
    89 000004EA 3E00                <1>
    90 000004EC 0D2020202020202020- <1> .s3:    db  0x0D, "        ", 0x0D, 0
    90 000004F5 0D00                <1>
    91                              <1> 
    92 000004F7 00                  <1> ALIGN 4,    db  0
    93 000004F8 00<rept>            <1> .b0:    times   E820_RECORD_SIZE    db  0   ; system memmap buffer
    94                              <1> 
    95                              <1> 
    96                              <1> ; void put_mem_info(int16 addr)
    97                              <1> ; nested func
    98                              <1> 
    99                              <1> put_mem_info:
   100                              <1> 
   101                              <1>     ; build stack frame
   102 0000050C 55                  <1>     push    bp
   103 0000050D 89E5                <1>     mov     bp, sp
   104                              <1> 
   105                              <1>     ; save registers
   106 0000050F 53                  <1>     push    bx
   107 00000510 56                  <1>     push    si
   108                              <1> 
   109                              <1>     ; get addr
   110 00000511 8B7604              <1>     mov     si, [bp + 4]
   111                              <1> 
   112                              <1>     ; convert mem info from int to str
   113                              <1>     ; Base(64bit)
   114 00000514 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 6], .s2 + 0, 4, 16, 0b0100
   114 0000051B [EB05]FF7406E8FEFC- <1>
   114 00000523 83C40A              <1>
   115 00000526 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 4], .s2 + 4, 4, 16, 0b0100
   115 0000052D [EF05]FF7404E8ECFC- <1>
   115 00000535 83C40A              <1>
   116 00000538 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 2], .s3 + 0, 4, 16, 0b0100
   116 0000053F [F405]FF7402E8DAFC- <1>
   116 00000547 83C40A              <1>
   117 0000054A 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 0], .s3 + 4, 4, 16, 0b0100
   117 00000551 [F805]FF34E8C9FC83- <1>
   117 00000559 C40A                <1>
   118                              <1>     ; Length(64bit)
   119 0000055B 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 14], .s4 + 0, 4, 16, 0b0100
   119 00000562 [FD05]FF740EE8B7FC- <1>
   119 0000056A 83C40A              <1>
   120 0000056D 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 12], .s4 + 4, 4, 16, 0b0100
   120 00000574 [0106]FF740CE8A5FC- <1>
   120 0000057C 83C40A              <1>
   121 0000057F 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 10], .s5 + 0, 4, 16, 0b0100
   121 00000586 [0606]FF740AE893FC- <1>
   121 0000058E 83C40A              <1>
   122 00000591 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 8],  .s5 + 4, 4, 16, 0b0100
   122 00000598 [0A06]FF7408E881FC- <1>
   122 000005A0 83C40A              <1>
   123                              <1>     ; Type(32bit)
   124 000005A3 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 18], .s6 + 0, 4, 16, 0b0100
   124 000005AA [0F06]FF7412E86FFC- <1>
   124 000005B2 83C40A              <1>
   125 000005B5 6A046A106A0468-     <1>     cdecl   itoa, word  [si + 16], .s6 + 4, 4, 16, 0b0100
   125 000005BC [1306]FF7410E85DFC- <1>
   125 000005C4 83C40A              <1>
   126                              <1> 
   127 000005C7 68[EA05]E8F3FA83C4- <1>     cdecl   puts, .s1   ; display mem info(Base, Length)
   127 000005CF 02                  <1>
   128                              <1> 
   129 000005D0 8B5C10              <1>     mov     bx, [si + 16]
   130 000005D3 83E307              <1>     and     bx, 0x07            ; bx = type 0 ~ 5;
   131 000005D6 D1E3                <1>     shl     bx, 1               ; bx *= 2;
   132 000005D8 81C3[6C06]          <1>     add     bx, .tpstrlist      ; bx += .tpstrlist
   133 000005DC FF37E8DFFA83C402    <1>     cdecl   puts, word [bx]
   134                              <1> 
   135                              <1> 
   136                              <1>     ; return registers
   137 000005E4 5E                  <1>     pop     si
   138 000005E5 5B                  <1>     pop     bx
   139                              <1> 
   140                              <1>     ; destroy stack frame
   141 000005E6 89EC                <1>     mov     sp, bp
   142 000005E8 5D                  <1>     pop     bp
   143                              <1> 
   144 000005E9 C3                  <1>     ret
   145                              <1> 
   146                              <1> 
   147 000005EA 20                  <1> .s1:    db  " "
   148 000005EB 5A5A5A5A5A5A5A5A5F  <1> .s2:    db  "ZZZZZZZZ_"
   149 000005F4 5A5A5A5A5A5A5A5A20  <1> .s3:    db  "ZZZZZZZZ "
   150 000005FD 5A5A5A5A5A5A5A5A5F  <1> .s4:    db  "ZZZZZZZZ_"
   151 00000606 5A5A5A5A5A5A5A5A20  <1> .s5:    db  "ZZZZZZZZ "
   152 0000060F 5A5A5A5A5A5A5A5A00  <1> .s6:    db  "ZZZZZZZZ", 0
   153                              <1> 
   154 00000618 2028556E6B6E6F776E- <1> .t0:    db  " (Unknown)", 0x0A, 0x0D, 0
   154 00000621 290A0D00            <1>
   155 00000625 2028757361626C6529- <1> .t1:    db  " (usable)", 0x0A, 0x0D, 0
   155 0000062E 0A0D00              <1>
   156 00000631 202872657365727665- <1> .t2:    db  " (reserved)", 0x0A, 0x0D, 0
   156 0000063A 64290A0D00          <1>
   157 0000063F 202841435049206461- <1> .t3:    db  " (ACPI data)", 0x0A, 0x0D, 0
   157 00000648 7461290A0D00        <1>
   158 0000064E 202841435049204E56- <1> .t4:    db  " (ACPI NVS)", 0x0A, 0x0D, 0
   158 00000657 53290A0D00          <1>
   159 0000065C 2028626164206D656D- <1> .t5:    db  " (bad memory)", 0x0A, 0x0D, 0
   159 00000665 6F7279290A0D00      <1>
   160                              <1> 
   161 0000066C [1806][2506][3106]- <1> .tpstrlist: dw  .t0, .t1, .t2, .t3, .t4, .t5, .t0, .t0      ; each of these addresses is 16bit(real mode)
   161 00000672 [3F06][4E06][5C06]- <1>
   161 00000678 [1806][1806]        <1>
   138                                  
   139                                  stage_3rd:
   140 0000067C 68[FA06]E83EFA83C4-         cdecl   puts, .s0               ; display a message
   140 00000684 02                 
   141                                  
   142                                      ; get BIOS font data
   143 00000685 68[0002]E857FC83C4-         cdecl   get_font_data, FONT
   143 0000068D 02                 
   144                                  
   145                                      ; display font addr
   146 0000068E 6A046A106A0468-             cdecl   itoa, word[FONT.seg], .p1, 4, 16, 0b0100
   146 00000695 [1707]FF36[0002]E8-
   146 0000069C 83FB83C40A         
   147 000006A1 6A046A106A0468-             cdecl   itoa, word[FONT.off], .p2, 4, 16, 0b0100
   147 000006A8 [1C07]FF36[0202]E8-
   147 000006AF 70FB83C40A         
   148 000006B4 68[0907]E806FA83C4-         cdecl   puts, .s1
   148 000006BC 02                 
   149                                  
   150                                      ; display mem info
   151 000006BD E80FFD                      cdecl   get_mem_info
   152                                  
   153 000006C0 66A1[0402]                  mov     eax, [ACPI_DATA.adr]    ; 32bit
   154 000006C4 6683F800                    cmp     eax, 0
   155 000006C8 742D                        je      .10E
   156 000006CA 6A046A106A0468-             cdecl   itoa, ax, .p4, 4, 16, 0b0100
   156 000006D1 [3407]50E84AFB83C4-
   156 000006D9 0A                 
   157 000006DA 66C1E810                    shr     eax, 16
   158 000006DE 6A046A106A0468-             cdecl   itoa, ax, .p3, 4, 16, 0b0100
   158 000006E5 [3007]50E836FB83C4-
   158 000006ED 0A                 
   159                                  
   160 000006EE 68[2507]E8CCF983C4-         cdecl   puts, .s2
   160 000006F6 02                 
   161                                  
   162                                  .10E:
   163                                      ; transition to the 4th stage
   164 000006F7 E9A100                      jmp     stage_4
   165                                  
   166                                  
   167 000006FA 337264207374616765-     .s0:    db  "3rd stage...", 0x0A, 0x0D, 0
   167 00000703 2E2E2E0A0D00       
   168 00000709 20466F6E7420416464-     .s1:    db  " Font Address="
   168 00000712 726573733D         
   169 00000717 5A5A5A5A3A              .p1:    db  "ZZZZ:"
   170 0000071C 5A5A5A5A0A0D            .p2:    db  "ZZZZ", 0x0A, 0x0D
   171 00000722 0A0D00                          db  0x0A, 0x0D, 0
   172                                  
   173 00000725 204143504920646174-     .s2:    db  " ACPI data="
   173 0000072E 613D               
   174 00000730 5A5A5A5A                .p3:    db  "ZZZZ"
   175 00000734 5A5A5A5A0A0D00          .p4:    db  "ZZZZ", 0x0A, 0x0D, 0
   176                                  
   177                                      ; ----------------------------
   178                                      ; --- 4th stage of booting ---
   179                                      ; ----------------------------
   180                                  
   181                                      ; --- modules ---
   182                                      %include    "../modules/real/kbc.s"
     1                              <1> ; definitions of
     2                              <1> ; int16 KBC_Data_Write(int16 input_data),
     3                              <1> ; int16 KBC_Data_Read(int16 output_adr),
     4                              <1> ; int16 KBC_Cmd_Write(int16 cmd)
     5                              <1> 
     6                              <1> ; --------------------------------------
     7                              <1> ; int16 KBC_Data_Write(int16 input_data)
     8                              <1> ; return non-zero on success, and 0 on error 
     9                              <1> ; input_data : input_data for the buffer in KBC
    10                              <1> 
    11                              <1> 
    12                              <1> KBC_Data_Write:
    13                              <1> 
    14                              <1>     ; build stack frame
    15 0000073B 55                  <1>     push    bp
    16 0000073C 89E5                <1>     mov     bp, sp
    17                              <1> 
    18                              <1>     ; save registers
    19 0000073E 51                  <1>     push    cx
    20                              <1> 
    21 0000073F B90000              <1>     mov     cx, 0           ; cnt = 0;
    22                              <1> .10L:                       ; do {
    23 00000742 E464                <1>     in      al, 0x64            ; get KBC status
    24                              <1> 
    25 00000744 A802                <1>     test    al, 0x02            ; check input buffer status
    26                              <1>                                 ; must be clear before attempting to write data to IO port 0x60 or IO port 0x64
    27 00000746 E0FA                <1>     loopnz  .10L            ; } while (--CX && !ZF);
    28                              <1> 
    29 00000748 83F900              <1>     cmp     cx, 0           ; if cnt == 0 again, it means time-out
    30 0000074B 7405                <1>     jz      .20E            ; if (CX) {
    31 0000074D 8A4604              <1>     mov     al, [bp + 4]        ; AL = input_data;
    32 00000750 E660                <1>     out     0x60, al            ; outp(0x60, AL);
    33                              <1>                             ; }
    34                              <1> 
    35                              <1> .20E:
    36 00000752 89C8                <1>     mov     ax, cx          ; return CX;
    37                              <1> 
    38                              <1>     ; return registers
    39 00000754 59                  <1>     pop     cx
    40                              <1> 
    41                              <1>     ; destroy stack frame
    42 00000755 89EC                <1>     mov     sp, bp
    43 00000757 5D                  <1>     pop     bp
    44                              <1> 
    45 00000758 C3                  <1>     ret
    46                              <1> 
    47                              <1> 
    48                              <1> ; -----------------------------------
    49                              <1> ; int16 KBC_Data_Read(int16 output_adr)
    50                              <1> ; return non-zero on success, and 0 on error 
    51                              <1> ; output_adr : adr for the data read from KBC buffer
    52                              <1> 
    53                              <1> KBC_Data_Read:
    54                              <1> 
    55                              <1>     ; build stack frame
    56 00000759 55                  <1>     push    bp
    57 0000075A 89E5                <1>     mov     bp, sp
    58                              <1> 
    59                              <1>     ; save registers
    60 0000075C 51                  <1>     push    cx
    61 0000075D 57                  <1>     push    di
    62                              <1> 
    63 0000075E B90000              <1>     mov     cx, 0           ; cnt = 0;
    64                              <1> .10L:                       ; do {
    65 00000761 E464                <1>     in      al, 0x64            ; get KBC status
    66                              <1> 
    67 00000763 A801                <1>     test    al, 0x01            ; check output buffer status
    68                              <1>                                 ; must be set before attempting to read data from IO port 0x60
    69 00000765 E1FA                <1>     loopz   .10L            ; } while (--CX && ZF);
    70                              <1> 
    71 00000767 83F900              <1>     cmp     cx, 0           ; if cnt == 0 again, it means time-out
    72 0000076A 7409                <1>     jz      .20E            ; if (CX) {
    73 0000076C B400                <1>     mov     ah, 0x00
    74 0000076E E460                <1>     in      al, 0x60            ; AL = inp(0x60);
    75                              <1>     
    76 00000770 8B7E04              <1>     mov     di, [bp + 4]        ; DI = output_adr;
    77 00000773 8905                <1>     mov     [di + 0], ax        ; *DI = AX;
    78                              <1>                             ; }
    79                              <1> 
    80                              <1> .20E:
    81 00000775 89C8                <1>     mov     ax, cx          ; return CX;
    82                              <1> 
    83                              <1>     ; return registers
    84 00000777 5F                  <1>     pop     di
    85 00000778 59                  <1>     pop     cx
    86                              <1> 
    87                              <1>     ; destroy stack frame
    88 00000779 89EC                <1>     mov     sp, bp
    89 0000077B 5D                  <1>     pop     bp
    90                              <1> 
    91 0000077C C3                  <1>     ret
    92                              <1> 
    93                              <1> 
    94                              <1> ; ------------------------------
    95                              <1> ; int16 KBC_Cmd_Write(int16 cmd)
    96                              <1> ; return non-zero on success, and 0 on error 
    97                              <1> ; cmd : command sending to KBC
    98                              <1> 
    99                              <1> KBC_Cmd_Write:
   100                              <1> 
   101                              <1>     ; build stack frame
   102 0000077D 55                  <1>     push    bp
   103 0000077E 89E5                <1>     mov     bp, sp
   104                              <1> 
   105                              <1>     ; save registers
   106 00000780 51                  <1>     push    cx
   107                              <1> 
   108 00000781 B90000              <1>     mov     cx, 0           ; cnt = 0;
   109                              <1> .10L:                       ; do {
   110 00000784 E464                <1>     in      al, 0x64            ; get KBC status
   111                              <1> 
   112 00000786 A802                <1>     test    al, 0x02            ; check input buffer status
   113                              <1>                                 ; must be clear before attempting to write data to IO port 0x60 or IO port 0x64
   114 00000788 E0FA                <1>     loopnz  .10L            ; } while (--CX && !ZF);
   115                              <1> 
   116 0000078A 83F900              <1>     cmp     cx, 0           ; if cnt == 0 again, it means time-out
   117 0000078D 7405                <1>     jz      .20E            ; if (CX) {
   118 0000078F 8A4604              <1>     mov     al, [bp + 4]        ; AL = input_data;
   119 00000792 E664                <1>     out     0x64, al            ; outp(0x60, AL);
   120                              <1>                             ; }
   121                              <1> 
   122                              <1> .20E:
   123 00000794 89C8                <1>     mov     ax, cx          ; return CX;
   124                              <1> 
   125                              <1>     ; return registers
   126 00000796 59                  <1>     pop     cx
   127                              <1> 
   128                              <1>     ; destroy stack frame
   129 00000797 89EC                <1>     mov     sp, bp
   130 00000799 5D                  <1>     pop     bp
   131                              <1> 
   132 0000079A C3                  <1>     ret
   183                                  
   184                                  stage_4:
   185 0000079B 68[7008]E81FF983C4-         cdecl   puts, .s0               ; display a message
   185 000007A3 02                 
   186                                  
   187                                      ; enabling the A20 line
   188 000007A4 FA                          cli
   189 000007A5 68AD00E8D2FF83C402          cdecl   KBC_Cmd_Write, 0xAD     ; Disable first PS/2 port(keyboard)
   190                                  
   191 000007AE 68D000E8C9FF83C402          cdecl   KBC_Cmd_Write, 0xD0     ; Read Controller Output Port
   192 000007B7 68[B908]E89CFF83C4-         cdecl   KBC_Data_Read, .key
   192 000007BF 02                 
   193 000007C0 8A1E[B908]                  mov     bl, [.key]
   194 000007C4 80CB02                      or      bl, 0x02                ; enable A20 line
   195                                  
   196 000007C7 68D100E8B0FF83C402          cdecl   KBC_Cmd_Write, 0xD1     ; Write next byte to Controller Output Port
   197 000007D0 53E867FF83C402              cdecl   KBC_Data_Write, bx
   198                                  
   199 000007D7 68AE00E8A0FF83C402          cdecl   KBC_Cmd_Write, 0xAE     ; Enable first PS/2 port(keyboard)
   200 000007E0 FB                          sti
   201                                  
   202                                      ; print("A20 Gate Enabled.\n");
   203 000007E1 68[7F08]E8D9F883C4-         cdecl   puts, .s1
   203 000007E9 02                 
   204                                  
   205                                  
   206                                  
   207                                      ; keyboard led test
   208 000007EA 68[9408]E8D0F883C4-         cdecl   puts, .s2                                   ; print("Keyboard LED Test...")
   208 000007F2 02                 
   209 000007F3 BB0000                      mov     bx, 0
   210                                  .10L:                                                   ; do {
   211 000007F6 B400                        mov     ah, 0x00
   212 000007F8 CD16                        int     0x16                                        ;   AL = 1 character input
   213                                  
   214 000007FA 3C31                        cmp     al, '1'
   215 000007FC 7266                        jb      .10E
   216                                  
   217 000007FE 3C33                        cmp     al, '3'
   218 00000800 7762                        ja      .10E
   219                                  
   220 00000802 88C1                        mov     cl, al
   221 00000804 FEC9                        dec     cl
   222 00000806 80E103                      and     cl, 0x03                                    ;   cl = 0, 1 or 2
   223 00000809 B80100                      mov     ax, 0x0001
   224 0000080C D3E0                        shl     ax, cl
   225 0000080E 31C3                        xor     bx, ax                                      ;   set up a bit flag
   226                                  
   227                                      ; Set LEDs
   228 00000810 FA                          cli
   229 00000811 68AD00E866FF83C402          cdecl   KBC_Cmd_Write, 0xAD                         ;   Disable first PS/2 port(keyboard)
   230                                  
   231 0000081A 68ED00E81BFF83C402          cdecl   KBC_Data_Write, 0xED                        ;   LED command
   232 00000823 68[B908]E830FF83C4-         cdecl   KBC_Data_Read, .key
   232 0000082B 02                 
   233 0000082C 803E[B908]FA                cmp     [.key], byte 0xFA                           ;   if (key == ACK) {
   234 00000831 7509                        jne     .11F
   235 00000833 53E804FF83C402              cdecl   KBC_Data_Write, bx                          ;     set LEDs
   236 0000083A EB1C                        jmp     .11E                                        ;   }
   237                                  .11F:                                                   ;   else {
   238 0000083C 6A046A106A0268-             cdecl   itoa, word [.key], .e1, 2, 16, 0b0100       ;     print("[response byte]")
   238 00000843 [B508]FF36[B908]E8-
   238 0000084A D5F983C40A         
   239 0000084F 68[B408]E86BF883C4-         cdecl   puts, .e0
   239 00000857 02                 
   240                                  .11E:                                                   ;   }
   241 00000858 68AE00E81FFF83C402          cdecl   KBC_Cmd_Write, 0xAE                         ;   Enable first PS/2 port(keyboard)
   242 00000861 FB                          sti
   243 00000862 EB92                        jmp     .10L                                        ; } while(1);
   244                                  
   245                                  .10E:
   246                                  
   247 00000864 68[AA08]E856F883C4-         cdecl   puts, .s3   ; print("(done)")
   247 0000086C 02                 
   248                                  
   249                                      ; transition to the 5th stage
   250 0000086D E9BC00                      jmp     stage_5
   251                                  
   252 00000870 347468207374616765-     .s0:    db  "4th stage...", 0x0A, 0x0D, 0
   252 00000879 2E2E2E0A0D00       
   253 0000087F 204132302047617465-     .s1:    db  " A20 Gate Enabled.", 0x0A, 0x0D, 0
   253 00000888 20456E61626C65642E-
   253 00000891 0A0D00             
   254 00000894 204B6579626F617264-     .s2:    db  " Keyboard LED Test...", 0
   254 0000089D 204C45442054657374-
   254 000008A6 2E2E2E00           
   255 000008AA 2028646F6E65290A0D-     .s3:    db  " (done)", 0x0A, 0x0D, 0
   255 000008B3 00                 
   256 000008B4 5B                      .e0:    db  "["
   257 000008B5 5A5A5D00                .e1:    db  "ZZ]", 0
   258                                  
   259 000008B9 0000                    .key:   dw  0
   260                                  
   261                                  
   262                                      ; ----------------------------
   263                                      ; --- 5th stage of booting ---
   264                                      ; ----------------------------
   265                                  
   266                                      ; --- modules ---
   267                                      %include    "../modules/real/lba_chs.s"
     1                              <1> ; void lba_chs(struct drive *drive, struct drive *drv_chs, int16 lba);
     2                              <1> 
     3                              <1> ; return non-zero on success, and 0 on error
     4                              <1> ; drive : addr to drive params
     5                              <1> ; drv_chs : addr to CHS (struct drive) converted from LBA
     6                              <1> ; lba : this will be converted to CHS
     7                              <1> 
     8                              <1> 
     9                              <1> lba_chs:
    10                              <1> 
    11                              <1>     ; build stack frame
    12 000008BB 55                  <1>     push    bp
    13 000008BC 89E5                <1>     mov     bp, sp
    14                              <1> 
    15                              <1>     ; save registers
    16 000008BE 50                  <1>     push    ax
    17 000008BF 53                  <1>     push    bx
    18 000008C0 52                  <1>     push    dx
    19 000008C1 56                  <1>     push    si
    20 000008C2 57                  <1>     push    di
    21                              <1> 
    22                              <1> 
    23                              <1>     ; convert LBA to CHS
    24 000008C3 8B7604              <1>     mov     si, [bp + 4]        ; SI = *drive;
    25 000008C6 8B7E06              <1>     mov     di, [bp + 6]        ; DI = *drive_chs;
    26                              <1> 
    27                              <1>     ; calculate num of sectors per cylinder
    28 000008C9 8A4404              <1>     mov     al, [si + drive.head]
    29 000008CC F66406              <1>     mul     byte [si + drive.sect]  ; AX = num of heads * num of sects per track
    30 000008CF 89C3                <1>     mov     bx, ax
    31                              <1> 
    32                              <1>     ; calculate C
    33 000008D1 BA0000              <1>     mov     dx, 0
    34 000008D4 8B4608              <1>     mov     ax, [bp + 8]
    35 000008D7 F7F3                <1>     div     bx                      ; AX = DX:AX / BX, DX = DX:AX % BX;
    36 000008D9 894502              <1>     mov     [di + drive.cyln], ax
    37                              <1> 
    38                              <1>     ; calculate H and S
    39 000008DC 89D0                <1>     mov     ax, dx
    40 000008DE F67406              <1>     div     byte [si + drive.sect]  ; AH = AX % num of sects per track;
    41                              <1>                                     ; AL = AX / num of sects per track;
    42 000008E1 0FB6D4              <1>     movzx   dx, ah                  ; DX = S
    43 000008E4 B400                <1>     mov     ah, 0x00                ; AX = C
    44 000008E6 894504              <1>     mov     [di + drive.head], ax
    45 000008E9 895506              <1>     mov     [di + drive.sect], dx
    46                              <1> 
    47                              <1> 
    48                              <1>     ; return registers
    49 000008EC 5F                  <1>     pop     di
    50 000008ED 5E                  <1>     pop     si
    51 000008EE 5A                  <1>     pop     dx
    52 000008EF 5B                  <1>     pop     bx
    53 000008F0 58                  <1>     pop     ax
    54                              <1> 
    55                              <1>     ; destroy stack frame
    56 000008F1 89EC                <1>     mov     sp, bp
    57 000008F3 5D                  <1>     pop     bp
    58                              <1> 
    59 000008F4 C3                  <1>     ret
   268                                      %include    "../modules/real/read_lba.s"
     1                              <1> ; int16 read_lba(struct drice *drive, int16 lba, int 16 sect, int16 dst);
     2                              <1> 
     3                              <1> ; return number of sectors read
     4                              <1> ; drive: addr to drive struct of drive params
     5                              <1> ; sect: number of read sectors
     6                              <1> ; dst: dst addr
     7                              <1> 
     8                              <1> ; can't call this func before DS = 0, maybe
     9                              <1> 
    10                              <1> 
    11                              <1> read_lba:
    12                              <1> 
    13                              <1>     ; build stack frame
    14 000008F5 55                  <1>     push    bp
    15 000008F6 89E5                <1>     mov     bp, sp
    16                              <1> 
    17                              <1>     ; save registers
    18 000008F8 56                  <1>     push    si
    19                              <1> 
    20                              <1>     ; get drive params
    21 000008F9 8B7604              <1>     mov     si, [bp + 4]
    22                              <1> 
    23                              <1>     ; convert to CHS from LBA
    24 000008FC 8B4606              <1>     mov     ax, [bp + 6]
    25 000008FF 5068[2409]56E8B4FF- <1>     cdecl   lba_chs, si, .chs, ax
    25 00000907 83C406              <1>
    26                              <1> 
    27                              <1>     ; copy drive number
    28 0000090A 8A04                <1>     mov     al, [si + drive.no]
    29 0000090C A2[2409]            <1>     mov     [.chs + drive.no], al
    30                              <1> 
    31                              <1>     ; read sectors
    32 0000090F FF760AFF760868-     <1>     cdecl   read_chs, .chs, word [bp + 8], word [bp + 10]
    32 00000916 [2409]E803F883C406  <1>
    33                              <1> 
    34                              <1> 
    35                              <1>     ; return registers
    36 0000091E 5E                  <1>     pop     si
    37                              <1> 
    38                              <1>     ; destroy stack frame
    39 0000091F 89EC                <1>     mov     sp, bp
    40 00000921 5D                  <1>     pop     bp
    41                              <1> 
    42 00000922 C3                  <1>     ret
    43                              <1> 
    44 00000923 90                  <1> ALIGN 2
    45 00000924 00<rept>            <1> .chs:   times drive_size    db  0x00
   269                                  
   270                                  stage_5:
   271 0000092C 68[5809]E88EF783C4-         cdecl   puts, .s0               ; print("5th stage...");
   271 00000934 02                 
   272                                  
   273                                      ; load the kernel
   274 00000935 68009C6A106A1068-           cdecl   read_lba, BOOT, BOOT_SECT, KERNEL_SECT, BOOT_END
   274 0000093D [B800]E8B3FF83C408 
   275 00000945 83F810                      cmp     ax, KERNEL_SECT
   276 00000948 740C                        jz      .10E                    ; can't load kernel, then reboot
   277 0000094A 68[6709]E870F783C4-         cdecl   puts, .e0
   277 00000952 02                 
   278 00000953 E889F7                      call    reboot
   279                                  
   280                                  .10E:
   281                                      ; transition to the 6th stage
   282 00000956 EB29                        jmp     stage_6
   283                                  
   284 00000958 357468207374616765-     .s0:    db  "5th stage...", 0x0A, 0x0D, 0
   284 00000961 2E2E2E0A0D00       
   285 00000967 204661696C75726520-     .e0:    db  " Failure load kernel...", 0x0A, 0x0D, 0
   285 00000970 6C6F6164206B65726E-
   285 00000979 656C2E2E2E0A0D00   
   286                                  
   287                                  
   288                                      ; ----------------------------
   289                                      ; --- 6th stage of booting ---
   290                                      ; ----------------------------
   291                                  stage_6:
   292 00000981 68[9909]E839F783C4-         cdecl   puts, .s0               ; display a message
   292 00000989 02                 
   293                                  
   294                                      ; waiting for space key input
   295                                  .10L:
   296 0000098A B400                        mov     ah, 0x00                ; do {
   297 0000098C CD16                        int     0x16                    ;   al = 1 character input
   298 0000098E 3C20                        cmp     al, ' '                 ;   zf = (al == ' ')
   299 00000990 75F8                        jne     .10L                    ; } while (!zf)
   300                                  
   301                                      ; Set Video Mode
   302 00000992 B81200                      mov     ax, 0x12                ; VGA 640x480 16 color graphics 
   303 00000995 CD10                        int     0x10
   304                                  
   305                                      ; while(1)
   306 00000997 EBFE                        jmp     $
   307                                  
   308 00000999 367468207374616765-     .s0:    db  "6th stage...", 0x0A, 0x0D, 0x0A, 0x0D
   308 000009A2 2E2E2E0A0D0A0D     
   309 000009A9 205B50757368205350-             db  " [Push SPACE key to protect mode...]", 0x0A, 0x0D, 0
   309 000009B2 414345206B65792074-
   309 000009BB 6F2070726F74656374-
   309 000009C4 206D6F64652E2E2E5D-
   309 000009CD 0A0D00             
   310                                  
   311                                  
   312                                  ; --- padding ---
   313 000009D0 00<rept>                times BOOT_SIZE - ($- $$)  db  0   ; up to 8K
